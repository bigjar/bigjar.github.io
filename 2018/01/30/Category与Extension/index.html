<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Category与Extension | MrHup.code</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在Objective-C中，要扩展一个类的方法，首先想到的应该是继承，这是面向对象语言的一个特性。继承可以很方便的增加方法，属性等，同时还可以覆写父类的方法。但是，对于大型而复杂的类，继承会导致维护困难。这时Category就可以发挥作用了。 什么是CategoryCategory是Objective-C 2.0之后添加的语言特性，其主要作用是为已经存在的类添加方法。通过它，你可以  把代码分散到">
<meta property="og:type" content="article">
<meta property="og:title" content="Category与Extension">
<meta property="og:url" content="http://yoursite.com/2018/01/30/Category%E4%B8%8EExtension/index.html">
<meta property="og:site_name" content="MrHup.code">
<meta property="og:description" content="在Objective-C中，要扩展一个类的方法，首先想到的应该是继承，这是面向对象语言的一个特性。继承可以很方便的增加方法，属性等，同时还可以覆写父类的方法。但是，对于大型而复杂的类，继承会导致维护困难。这时Category就可以发挥作用了。 什么是CategoryCategory是Objective-C 2.0之后添加的语言特性，其主要作用是为已经存在的类添加方法。通过它，你可以  把代码分散到">
<meta property="og:locale" content="cn">
<meta property="article:published_time" content="2018-01-30T01:43:17.000Z">
<meta property="article:modified_time" content="2020-02-26T10:14:59.933Z">
<meta property="article:author" content="MrHup">
<meta property="article:tag" content="Objective-C">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MrHup.code" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MrHup.code</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">HeapAndStack</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Category与Extension" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/30/Category%E4%B8%8EExtension/" class="article-date">
  <time datetime="2018-01-30T01:43:17.000Z" itemprop="datePublished">2018-01-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Category与Extension
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Objective-C中，要扩展一个类的方法，首先想到的应该是继承，这是面向对象语言的一个特性。继承可以很方便的增加方法，属性等，同时还可以覆写父类的方法。但是，对于大型而复杂的类，继承会导致维护困难。这时Category就可以发挥作用了。</p>
<h2 id="什么是Category"><a href="#什么是Category" class="headerlink" title="什么是Category"></a>什么是Category</h2><p>Category是Objective-C 2.0之后添加的语言特性，其主要作用是为已经存在的类添加方法。通过它，你可以</p>
<ul>
<li>把代码分散到多个类中-比如把类中的不同模块的方法放入几个不同的category中。</li>
<li>申明私有方法。</li>
<li>模拟多继承。</li>
<li>公开framework的私有方法。</li>
</ul>
<h2 id="Category的使用注意"><a href="#Category的使用注意" class="headerlink" title="Category的使用注意"></a>Category的使用注意</h2><p>因为谁都可以扩展一个类，所以在使用Category时有几点需要注意的地方。</p>
<p>比如你的应用扩展了NSString类，同时你链接的第三方库也扩展了NSString类。刚好两者扩展了一个相同的方法名。由于Category是在runtime时实现的，这是加载哪个实现是不确定的，从而会导致不确定的结果。</p>
<p>又比如你扩展了<code>NSSortDescriptor</code>类，增加了一个<code>sortDescriptorWithKey:ascending:</code>方法。在低版本的iOS中这个方法是不存在的，但是高版本的iOS中，这个方法是默认被实现的。这时就会有一个命名冲突。</p>
<p>因此为了避免上述的情况，建议是在扩展类的方法名前加入前缀。比如：</p>
<pre><code>@interface NSSortDescriptor (XYZAdditions)
+ (id)xyz_sortDescriptorWithKey:(NSString *)key ascending:(BOOL)ascending;
@end</code></pre><h2 id="Category与Extension的区别"><a href="#Category与Extension的区别" class="headerlink" title="Category与Extension的区别"></a>Category与Extension的区别</h2><p>Extension像一个匿名的Category，但是两者差别很大。Extension只能附加在源码的类上面，它是编译时决定的，从而可以添加实例变量。而Category是在运行时决定的，内存布局已经确定，从而不可以添加实例变量。Extension常用来隐藏实现细节，比如不想对外公开的方法和实例变量等。</p>
<h2 id="Category源码实现"><a href="#Category源码实现" class="headerlink" title="Category源码实现"></a>Category源码实现</h2><p>通过查看runtime源码，发现category实际上是一个叫做category_t的结构体</p>
<pre><code>typedef struct category_t {
  const char *name;
  classref_t cls;
  struct method_list_t *instanceMethods;
  struct method_list_t *classMethods;
  struct protocol_list_t *protocols;
  struct property_list_t *instanceProperties;
}</code></pre><p>从中我们可以发现，它可以添加实例方法、类方法、协议、实例属性。<br>接下去我们看一下category是如何加载的。</p>
<pre><code>void _objc_init(void) {
  ...
  dyld_register_image_state_change_handler(dyld_image_state_bound,
                                     1/*batch*/, &amp;map_2_images);
  ...
}</code></pre><p>首先通过runtime的入口函数<code>_objc_init</code>方法中加载<code>map_2_images</code>。</p>
<pre><code>const char * map_2_images(enum dyld_image_states state, uint32_t infoCount,
         const struct dyld_image_info infoList[])
{
    rwlock_writer_t lock(runtimeLock);
    return map_images_nolock(state, infoCount, infoList);
}</code></pre><p>然后<code>map_2_images</code>通过加锁访问<code>map_images_nolock</code>。</p>
<pre><code>const char *map_images_nolock(enum dyld_image_states state, uint32_t infoCount,
            const struct dyld_image_info infoList[])
{
  ...
  _read_images(hList, hCount);
  ...
}</code></pre><p>在这里通过<code>_read_images</code>去读取image。</p>
<pre><code>void _read_images(header_info **hList, uint32_t hCount)
{
  ...
  // Discover categories.
  for (EACH_HEADER) {
    category_t **catlist =
      _getObjc2CategoryList(hi, &amp;count);
      for (i = 0; i &lt; count; i++) {
        category_t *cat = catlist[i];
        Class cls = remapClass(cat-&gt;cls);
        ...
        // Process this category.
        // First, register the category with its target class.
        // Then, rebuild the class&apos;s method lists (etc) if
        // the class is realized.
        bool classExists = NO;
        if (cat-&gt;instanceMethods ||  cat-&gt;protocols  
          ||  cat-&gt;instanceProperties)
        {
          addUnattachedCategoryForClass(cat, cls, hi);
          if (cls-&gt;isRealized()) {
              remethodizeClass(cls);
              classExists = YES;
          }
          ...
        }

        if (cat-&gt;classMethods  ||  cat-&gt;protocols  
          /* ||  cat-&gt;classProperties */)
        {
          addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);
          if (cls-&gt;ISA()-&gt;isRealized()) {
              remethodizeClass(cls-&gt;ISA());
          }
          ...
        }
      }
    }
    ...
}</code></pre><p>上述代码执行的操作就是找到相应的category，分别把category的实例方法、协议、属性加入到类上，类方法、协议添加到元类上面。首先注册category到目标类上去，然后如果类或则元类已经实现，则重构它的方法列表。<br>具体的执行是<code>addUnattachedCategoryForClass</code>和<code>remethodizeClass</code>方法。</p>
<pre><code>static void addUnattachedCategoryForClass(category_t *cat, Class cls,
                                          header_info *catHeader)
{
    runtimeLock.assertWriting();

    // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead
    NXMapTable *cats = unattachedCategories();
    category_list *list;

    list = (category_list *)NXMapGet(cats, cls);
    if (!list) {
        list = (category_list *)
            calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1);
    } else {
        list = (category_list *)
            realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1));
    }
    list-&gt;list[list-&gt;count++] = (locstamped_category_t){cat, catHeader};
    NXMapInsert(cats, cls, list);
}</code></pre><p><code>addUnattachedCategoryForClass</code>方法把类和category做了一个关联映射。</p>
<pre><code>static void remethodizeClass(Class cls)
{
...
attachCategories(cls, cats, true /*flush caches*/);        
...
}</code></pre><p>而<code>remethodizeClass</code>方法内部其实调用了<code>attachCategories</code>方法。<code>attachCategories</code>方法是真正把category里面的东西加入到类中去。</p>
<pre><code>static void
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
...
while (i--) {
    auto&amp; entry = cats-&gt;list[i];

    method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);
    if (mlist) {
        mlists[mcount++] = mlist;
        fromBundle |= entry.hi-&gt;isBundle();
    }

    property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta);
    if (proplist) {
        proplists[propcount++] = proplist;
    }

    protocol_list_t *protolist = entry.cat-&gt;protocols;
    if (protolist) {
        protolists[protocount++] = protolist;
    }
}

auto rw = cls-&gt;data();
prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
rw-&gt;methods.attachLists(mlists, mcount);
free(mlists);
if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);

rw-&gt;properties.attachLists(proplists, propcount);
free(proplists);

rw-&gt;protocols.attachLists(protolists, protocount);
free(protolists);
}</code></pre><p>从中我们可以看到，这里把category中的方法、属性、协议添加到原有的类上面。</p>
<blockquote>
<p>这里说明一下，category中的方法并不会覆盖原有的方法，如果存在两个相同的方法。但是由于category中的方法是放在前面的，所以在消息转发查找方法时会先找到category的方法，从而形成了覆盖原有方法的错觉。</p>
</blockquote>
<h2 id="Category与-load"><a href="#Category与-load" class="headerlink" title="Category与+load()"></a>Category与+load()</h2><p>runtime在加载类和分类时，是通过调用各自的指针分开加载的，因此既会执行类的<code>+load()</code>方法，也会执行分类的<code>+load()</code>方法。但是当我们手动调用<code>+load()</code>方法时，则分类的<code>+load()</code>方法会先于类的<code>+load()</code>方法，并造成覆盖的错觉。测试代码如下：</p>
<pre><code>#import &quot;Person.h&quot;

@implementation Person

+ (void)load {
  NSLog(@&quot;main load&quot;);
}

@end

@implementation Person (Fly)

+ (void)load {
  NSLog(@&quot;category load&quot;);
}

- (void)fly {
  NSLog(@&quot;I can fly&quot;);
}

- (void)jump {
  NSLog(@&quot;I can jump&quot;);
}

@end


#import &quot;ViewController.h&quot;
#import &quot;Person.h&quot;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    [Person load];
}

@end</code></pre><p>结果如下：</p>
<pre><code>2018-01-30 17:02:44.442283+0800 CategoryDemo[23354:4396068] main load
2018-01-30 17:02:44.442758+0800 CategoryDemo[23354:4396068] category load
2018-01-30 17:02:44.599671+0800 CategoryDemo[23354:4396068] category load</code></pre><p>从结果中可知先调用了类的<code>+load()</code>方法，再调用了分类的<code>+load()</code>方法。最后主动调用时，调用了分类的<code>+load()</code>方法。</p>
<h2 id="Category与实例变量"><a href="#Category与实例变量" class="headerlink" title="Category与实例变量"></a>Category与实例变量</h2><p>从源码中可知，category是无法添加实例变量的。但是有时往往需要实例变量，这时可以通过runtime关联对象做一个假的实例变量。</p>
<pre><code>-------------------------------
@interface Person (Fly)

@property(nonatomic,copy) NSString *name;

@end


-------------------------------
static NSString *associateKey = @&quot;name&quot;;

@implementation Person (Fly)


- (void)setName:(NSString *)name {
  objc_setAssociatedObject(self, &amp;associateKey, name, OBJC_ASSOCIATION_COPY);
}

- (NSString *)name {
  return objc_getAssociatedObject(self, &amp;associateKey);
}

@end</code></pre><p>然后我们分析一下<code>objc_setAssociatedObject</code>的源码。</p>
<pre><code>void objc_setAssociatedObject(id object, const void *key, id value,
                     objc_AssociationPolicy policy)
{
  ObjcAssociation old_association(0, nil);
  id new_value = value ? acquireValue(value, policy) : nil;
  {
      AssociationsManager manager;
      AssociationsHashMap &amp;associations(manager.associations());
      disguised_ptr_t disguised_object = DISGUISE(object);
      if (new_value) {
        ...
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        ObjectAssociationMap *refs = i-&gt;second;
        ObjectAssociationMap::iterator j = refs-&gt;find(key);
        (*refs)[key] = ObjcAssociation(policy, new_value);
        ...
      }
      ...
  }
  ...   
}</code></pre><p>从中可以发现，这个<code>associateObject</code>是由<code>AssociationsManager</code>管理的，<code>AssociationsManager</code>里面有一个<code>AssociationsHashMap</code>的哈希表，用来存储所有的object，其key值为这个objcet的地址。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="noopener">1.Category</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW2" target="_blank" rel="noopener">2.Customizing Existing Classes</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/" target="_blank" rel="noopener">3.Objective-C Category 的实现原理
</a><br><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">4.深入理解Objective-C：Category
</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/30/Category%E4%B8%8EExtension/" data-id="ck736a2q00008ees6cvjghm2h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/" rel="tag">Objective-C</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/09/%E4%B8%80%E6%AC%A1%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B9%8B%E6%97%85/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          一次日志统计分析之旅
        
      </div>
    </a>
  
  
    <a href="/2018/01/29/%E8%A7%A3%E6%9E%90objc-msgSend-ARM64/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">解析objc_msgSend(ARM64)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Actuator/" rel="tag">Actuator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flink/" rel="tag">Flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flume/" rel="tag">Flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Grafana/" rel="tag">Grafana</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/" rel="tag">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVO/" rel="tag">KVO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C/" rel="tag">Objective-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prometheus/" rel="tag">Prometheus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/" rel="tag">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/akka/" rel="tag">akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/block/" rel="tag">block</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flink/" rel="tag">flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runloop/" rel="tag">runloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime/" rel="tag">runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scrapy/" rel="tag">scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/" rel="tag">函数派发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E8%BF%9E/" rel="tag">响应连</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E9%92%A5/" rel="tag">密钥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Actuator/" style="font-size: 12.5px;">Actuator</a> <a href="/tags/Flink/" style="font-size: 12.5px;">Flink</a> <a href="/tags/Flume/" style="font-size: 10px;">Flume</a> <a href="/tags/Grafana/" style="font-size: 10px;">Grafana</a> <a href="/tags/Hadoop/" style="font-size: 12.5px;">Hadoop</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/Prometheus/" style="font-size: 10px;">Prometheus</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Spring-Boot/" style="font-size: 12.5px;">Spring Boot</a> <a href="/tags/Swift/" style="font-size: 12.5px;">Swift</a> <a href="/tags/akka/" style="font-size: 10px;">akka</a> <a href="/tags/block/" style="font-size: 10px;">block</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/kafka/" style="font-size: 12.5px;">kafka</a> <a href="/tags/runloop/" style="font-size: 10px;">runloop</a> <a href="/tags/runtime/" style="font-size: 10px;">runtime</a> <a href="/tags/scrapy/" style="font-size: 10px;">scrapy</a> <a href="/tags/%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/" style="font-size: 10px;">函数派发</a> <a href="/tags/%E5%93%8D%E5%BA%94%E8%BF%9E/" style="font-size: 10px;">响应连</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 10px;">安全</a> <a href="/tags/%E5%AF%86%E9%92%A5/" style="font-size: 10px;">密钥</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">机器学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 17.5px;">源码分析</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Flink%E7%BD%91%E7%BB%9C%E6%A0%88%E5%8F%8A%E8%83%8C%E5%8E%8B%E7%9B%91%E6%8E%A7/">深入理解Flink网络栈及背压监控</a>
          </li>
        
          <li>
            <a href="/2019/11/08/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Flink%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%EF%BC%9A%E4%BF%A1%E5%B0%81%E8%83%8C%E8%AE%A1%E7%AE%97%E6%B3%95/">如何计算Flink集群规模：信封背计算法</a>
          </li>
        
          <li>
            <a href="/2018/12/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8Hadoop%E9%9B%86%E7%BE%A4/">如何搭建高可用Hadoop集群</a>
          </li>
        
          <li>
            <a href="/2018/11/13/Akka%E5%9C%A8Flink%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">Akka在Flink中的应用</a>
          </li>
        
          <li>
            <a href="/2018/08/19/Spring-Boot-Metrics%E7%9B%91%E6%8E%A7%E4%B9%8BPrometheus-Grafana/">Spring Boot Metrics监控之Prometheus&amp;Grafana</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 MrHup<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>