<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="暴露的状态:与Flink的状态交互"><meta name="keywords" content="Flink"><meta name="author" content="MrHook"><meta name="copyright" content="MrHook"><title>暴露的状态:与Flink的状态交互 | MrHook的时光机</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流处理：什么是状态"><span class="toc-number">2.</span> <span class="toc-text">流处理：什么是状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FLINK的Schema演进"><span class="toc-number">3.</span> <span class="toc-text">FLINK的Schema演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内部实现"><span class="toc-number">3.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink中Avro序列化实现"><span class="toc-number">3.2.</span> <span class="toc-text">Flink中Avro序列化实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写快照"><span class="toc-number">3.3.</span> <span class="toc-text">写快照</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态处理API：读、写和修改Flink状态"><span class="toc-number">4.</span> <span class="toc-text">状态处理API：读、写和修改Flink状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多与状态交互的方式"><span class="toc-number">5.</span> <span class="toc-text">更多与状态交互的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">MrHook</div><div class="author-info__description text-center">stay hungry, stay foolish</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">MrHook的时光机</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">暴露的状态:与Flink的状态交互</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着有状态流处理逐渐成为复杂时间驱动应用和实时分析系统的应用的越来越多，Flink逐渐成为业务逻辑处理和数据资产的基石。</p>
<p>为了使Flink开发者更好的体验状态处理，Flink社区在提供安全可靠的状态管理模式上作了很多工作。特别是，Flink开发者需要有足够多的手段来获取和修改状态。这些功能体现在多个Flink发布版本中：</p>
<ol>
<li>Flink可演进的状态schema</li>
<li>与状态后端交互的灵活性</li>
<li>状态处理API：一个读写，修改状态的工具</li>
</ol>
<p>这篇文章讨论社区关于Flink状态管理的相关工作，Flink如何使用不同的API和功能来改善现有的状态管理方式或者增加新的状态管理方式。</p>
<h2 id="流处理：什么是状态"><a href="#流处理：什么是状态" class="headerlink" title="流处理：什么是状态"></a>流处理：什么是状态</h2><p>首先解释流处理中状态的含义。有状态的流处理，状态主要由实时的(无界的)或者离线的(有界的)流经应用的数据信息构成。绝大多数不太重要的应用都是内置状态的：即使是简单的count操作，当数到10时，也需要记住已经数到9。<br>为了更好的了解Flink如何管理状态，可以把Flink想象成一个三层的状态抽象，如下图所示。</p>
<p><img src="/2020/02/27/%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%8A%B6%E6%80%81-%E4%B8%8EFlink%E7%9A%84%E7%8A%B6%E6%80%81%E4%BA%A4%E4%BA%92/managing-state-in-flink-visual-1.png" alt></p>
<p>在最上层，是Flink的用户代码，举个例子，<strong>KeyedProcessFunction</strong>包含了一些值的状态。这是一个简单的变量，它的值状态含义使它在运行时可以自动容错，扩展和查询。根据配置的状态后端，这些变量留在堆上或者磁盘上(RocksDB)，同时提供数据位置。最后，在升级时，比如引入新的功能或者bug修复，为了能够保持状态的有效，就引入了savepoints。</p>
<p>savepoint是一个应用在某个逻辑时刻的分布式的全局状态快照，并存储在外部的分布式文件系统或者HDFS、S3中。升级应用或者实现代码的变动 - 比如增加新的算子或者修改一个字段 - Flink任务通过状态后端的savepoint来加载状态就可以无缝衔接。</p>
<p><img src="/2020/02/27/%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%8A%B6%E6%80%81-%E4%B8%8EFlink%E7%9A%84%E7%8A%B6%E6%80%81%E4%BA%A4%E4%BA%92/managing-state-in-flink-visual-2.png" alt></p>
<!--请记住，Flink程序最有价值的组件就是状态，它携带者所有关于你现在在哪和你将去哪儿的信息。状态是Flink服务中最长久的组件，因为它在任务、算子、配置、新功能和bug修复都有体现。-->

<h2 id="FLINK的Schema演进"><a href="#FLINK的Schema演进" class="headerlink" title="FLINK的Schema演进"></a>FLINK的Schema演进</h2><p>想象这样一个Flink应用，它实现了<strong>KeyedProcessFunction</strong>函数并包含一些<strong>ValueState</strong>。因为有状态描述符，当注册一个类型时，Flink用户可以通过设置<strong>TypeInformation</strong>来告知Flink如何序列化字节。Flink的类型内在支持所有的基本类型比如longs、string、doubles、arrays和基本的集合类型比如lists和maps。此外，Flink还支持绝大多数重要的组合类型，比如Tuples、POJOS、Scala Case CLasses和Apache Avro。最后，如果一个应用的类型与上面的不匹配，开发者可以定制自己的序列器，或者使用Kryo。</p>
<p>通过FLink内部的序列化进行状态注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFunction</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Key</span>, <span class="title">Input</span>, <span class="title">Output</span>&gt; </span>&#123;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;MyState&gt; valueState;</span><br><span class="line">​</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> </span>&#123;</span><br><span class="line">    ValueStateDescriptor&lt;MyState&gt; descriptor =</span><br><span class="line">      <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">"my-state"</span>, TypeInformation.of(MyState<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">​</span><br><span class="line">    valueState = getRuntimeContext().getState(descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，应用的schema演进主要是因为业务逻辑的改变(增加或者减少字段或者修改数据类型)。在所有的例子中，schema是由它的序列化器决定，这可以想成数据库中的改变表声明。当一个状态变量第一次通过<strong>CREATE_TABLE</strong>命令来生成时，在执行上有很多选择。但是，当数据已经在表中时就会有很多限制，就必须使用<strong>ALTER_TABLE</strong>命令来升级或者修改表。Flink的Schema迁移遵循类似的原则，因为在savepoint上运行<strong>ALTER_TABLE</strong>也是非常有必要的。</p>
<p>Flink1.8支持了<a href="https://avro.apache.org/" target="_blank" rel="noopener">Apache Avro</a>(特别是<a href="https://avro.apache.org/docs/1.7.7/spec.html" target="_blank" rel="noopener">1.7.7 specification</a>)。通过Avro，演进的状态schema可以增加和移除类型，一般的和特殊的Avro数据类型交换。</p>
<p>在Flink1.9中，社区增加了POJOS的schema演进支持，包括从POJO类型移除已有字段和增加字段的能力。POJO的schema演进灵活性一般 - 与Avro比较 - 因为不太可能改变已经申明的字段类型或者POJO的类名，包括namespace。</p>
<p>随着社区关于schema演进的工作的推进，Flink开发者现在能够使用Avro和POJO格式来使得Flink状态后端向后兼容。未来的工作将是支持Scala Case Ckasses、Tuples和其他格式。</p>
<h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>Flink一直把状态当作API稳定性的核心，这样开发者总是能够从一个savepoint中恢复应用。由于schema演进，每次迁移需要向后兼容，并同时与不同的状态后端兼容。但是在Flink中，状态后端通过接口形式来处理存取字节。在实际情况中，这些状态后端区别很大，这就额外增加了schema演进的复杂度。</p>
<p>举个例子，堆状态后端支持懒序列化和快速的反序列化，使得总是在处理Java对象，序列化是在后台线程中执行。当应用恢复时，Flink将快速的反序列化数据然后执行用户代码。如果开发者插入了一个新的序列化器，反序列化是在Flink收到这个信息之前就发生的。</p>
<p>RocksDB状态后端是以完全相反的方式工作：它支持快速序列化 - 因为数据是存在硬盘上，并且RocksDB只消费字节数组。RocksDB提供懒反序列化是简单的通过下载文件到本地磁盘，使得Flink并不知道字节是什么直到序列化器被注册。</p>
<p>另一个挑战来源于不同用户代码版本在classpath上包含不同类，使得序列化器在运行时可能无法写savepoint。</p>
<p>为了解决以上挑战，我们引入了<strong>TypeSerializerSnapshot</strong>。<strong>TypeSerializerSnapshot</strong>把写序列化器配置存在快照中。当恢复数据时会读取这个配置并且检查与当前版本的兼容性。Flink提供以下操作</p>
<ul>
<li>读配置快照</li>
<li>使用新的用户代码</li>
<li>检查两者是否兼容</li>
<li>使用快照中的字节并向前移动或警告用户</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeSerializerSnapshot</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCurrentVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writeSnapshot</span><span class="params">(DataOutputView out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">readSnapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> readVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">      DataInputView in,</span></span></span><br><span class="line"><span class="function"><span class="params">      ClassLoader userCodeClassLoader)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">TypeSerializer&lt;T&gt; <span class="title">restoreSerializer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">TypeSerializerSchemaCompatibility&lt;T&gt; <span class="title">resolveSchemaCompatibility</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      TypeSerializer&lt;T&gt; newSerializer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Flink中Avro序列化实现"><a href="#Flink中Avro序列化实现" class="headerlink" title="Flink中Avro序列化实现"></a>Flink中Avro序列化实现</h3><p>Apache Avro是一种数据序列化格式，它很好的定义了schema迁移语义并同时支持读写schema。在正常的FLink执行中，读写schema是相同的。但是，当升级应用时，他们可能是不同的，Flink将能够从schema中迁移对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvroSerializerSnapshot</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">TypeSerializerSnapshot</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Schema runtimeSchema;</span><br><span class="line">  <span class="keyword">private</span> Schema previousSchema;</span><br><span class="line">​</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AvroSerializerSnapshot</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">​</span><br><span class="line">  AvroSerializerSnapshot(Schema schema) &#123;</span><br><span class="line">    <span class="keyword">this</span>.runtimeSchema = schema;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个是Avro序列化器的模版。它使用提供的schema并且代理给Avro处理所有的序列化和反序列化。让我们看一下<strong>TypeSerializerSnapshot</strong>在Avro中schema迁移中的实现。</p>
<h3 id="写快照"><a href="#写快照" class="headerlink" title="写快照"></a>写快照</h3><p>当序列化一个快照时，快照配置将写两个信息：当前的快照配置版本和序列化器配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSnapshot</span><span class="params">(DataOutputView out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeUTF(runtimeSchema.toString(<span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>版本是用来标记快照配置版本，当<strong>writeSnapshot</strong>函数写所有的信息时，我们需要了解当前的格式；运行时schema。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readSnapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> readVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">      DataInputView in,</span></span></span><br><span class="line"><span class="function"><span class="params">      ClassLoader userCodeClassLoader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> readVersion == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> String previousSchemaDefinition = in.readUTF();</span><br><span class="line">    <span class="keyword">this</span>.previousSchema = parseAvroSchema(previousSchemaDefinition);</span><br><span class="line">    <span class="keyword">this</span>.runtimeType = findClassOrFallbackToGeneric(</span><br><span class="line">      userCodeClassLoader,</span><br><span class="line">      previousSchema.getFullName());</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">this</span>.runtimeSchema = tryExtractAvroSchema(userCodeClassLoader, runtimeType);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当Flink恢复时，它能够读取写schema曾经序列化的数据。当前运行时schema在classpath中通过java反射机制来发现。</p>
<p>一旦拥有两个schema，就可以比较兼容性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TypeSerializerSchemaCompatibility&lt;T&gt; <span class="title">resolveSchemaCompatibility</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      TypeSerializer&lt;T&gt; newSerializer)</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (!(newSerializer <span class="keyword">instanceof</span> AvroSerializer)) &#123;</span><br><span class="line">      <span class="keyword">return</span> TypeSerializerSchemaCompatibility.incompatible();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(previousSchema, runtimeSchema)) &#123;</span><br><span class="line">      <span class="keyword">return</span> TypeSerializerSchemaCompatibility.compatibleAsIs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>schema使用Avro的兼容性检查比较，它们要么是兼容的，要么是不兼容的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SchemaPairCompatibility compatibility = SchemaCompatibility</span><br><span class="line">    .checkReaderWriterCompatibility(previousSchema, runtimeSchema);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> avroCompatibilityToFlinkCompatibility(compatibility);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果迁移时它们是兼容的，Flink将恢复一个新的序列化器，它能够读取旧的schema并且使用新的schema反序列化。</p>
<h2 id="状态处理API：读、写和修改Flink状态"><a href="#状态处理API：读、写和修改Flink状态" class="headerlink" title="状态处理API：读、写和修改Flink状态"></a>状态处理API：读、写和修改Flink状态</h2><p>状态处理API允许读写Flink的savepoints。比如：</p>
<ul>
<li><p>分析有趣模式的状态</p>
</li>
<li><p>通过检查状态差异来解决任务的问题</p>
</li>
<li><p>为新的应用加载状态</p>
</li>
<li><p>修改savepoint</p>
<ul>
<li><p>部署一个Flink任务时修改savepoint的最大并行度</p>
</li>
<li><p>在Flink中引入中断的的schema升级</p>
</li>
<li><p>在Flink savepoint中修正无效的状态</p>
</li>
</ul>
</li>
</ul>
<p>在<a href="https://flink.apache.org/feature/2019/09/13/state-processor-api.html" target="_blank" rel="noopener">先前的文章中</a>中，我们讨论了状态处理API的细节，Flink1.9中引入这个功能的动机和如何使用这个API。本质上，状态处理API基于关系模型，把Flink任务状态map到数据库，如下图所示。</p>
<p><img src="/2020/02/27/%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%8A%B6%E6%80%81-%E4%B8%8EFlink%E7%9A%84%E7%8A%B6%E6%80%81%E4%BA%A4%E4%BA%92/managing-state-in-flink-state-processor-api-visual-1.png" alt></p>
<p><img src="/2020/02/27/%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%8A%B6%E6%80%81-%E4%B8%8EFlink%E7%9A%84%E7%8A%B6%E6%80%81%E4%BA%A4%E4%BA%92/managing-state-in-flink-state-processor-api-visual-2.png" alt></p>
<h2 id="更多与状态交互的方式"><a href="#更多与状态交互的方式" class="headerlink" title="更多与状态交互的方式"></a>更多与状态交互的方式</h2><p>在随后的发布版本中，状态处理API将支持从窗口中读写，并且在Flink Table API 和 SQL中集成。</p>
<p>除了扩展状态处理API的使用范围，FLink社区还讨论了其他几种与状态交互的方式。其中一种是对所有的keyed状态后端统一savepoint格式(<a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-41%3A+Unify+Binary+format+for+Keyed+State" target="_blank" rel="noopener">FLIP-41</a>)。这种方式旨在所有的keyed状态后端的savepoint种引入了一个统一的二进制格式，可以减少状态后端的转换负载。同时，这样可以允许开发者已不同的状态后端重启应用 - 举个例子，heap状态后端和RocksDB状态后端的转换 - 依据应用在不同时刻的扩展性和演进。</p>
<p>社区同时在讨论在Flink的发布版本中加入干运行。这样，Flink允许开发者离线检测不匹配的升级，而不需要启动一个新的Flink应用。举个例子，Flink用户可以在不把状态加载回来或者启动一个Flink应用时，看到任务升级带来的拓扑或者schema的不兼容和从streaming graph中看到注册的状态信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://flink.apache.org/news/2020/01/29/state-unlocked-interacting-with-state-in-apache-flink.html" target="_blank" rel="noopener">State Unlocked: Interacting with State in Apache Flink</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">MrHook</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bigjar.github.io/2020/02/27/%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%8A%B6%E6%80%81-%E4%B8%8EFlink%E7%9A%84%E7%8A%B6%E6%80%81%E4%BA%A4%E4%BA%92/">https://bigjar.github.io/2020/02/27/%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%8A%B6%E6%80%81-%E4%B8%8EFlink%E7%9A%84%E7%8A%B6%E6%80%81%E4%BA%A4%E4%BA%92/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Flink/">Flink</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8-%E5%A4%8D%E5%88%B6/"><i class="fa fa-chevron-left">  </i><span>设计数据密集型应用-复制</span></a></div><div class="next-post pull-right"><a href="/2020/02/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Flink%E7%BD%91%E7%BB%9C%E6%A0%88%E5%8F%8A%E8%83%8C%E5%8E%8B%E7%9B%91%E6%8E%A7/"><span>深入理解Flink网络栈及背压监控</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By MrHook</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>