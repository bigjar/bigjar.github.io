<!DOCTYPE html><html lang="cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="MrHup"><meta name="copyright" content="MrHup"><title>HeapAndStack | MrHup.code</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">MrHup</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">MrHup.code</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">MrHup.code</div><div id="site-sub-title">HeapAndStack</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/NSOperation/">NSOperation</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Objective-C/">Objective-C</a></span><div class="content"><p>NSOperation表示了一个独立的计算单元。作为一个抽象类，它给了它的子类一个十分有用而且线程安全的方式来建立状态、优先级、依赖性和取消等的模型。你可以使用系统提供的<code>NSBlockOperation</code>和<code>NSInvocationOperation</code>方法来创建一个operation，也可以创建一个继承<code>NSOperation</code>抽象类的operation。</p>
<h2 id="异步vs同步Operations"><a href="#异步vs同步Operations" class="headerlink" title="异步vs同步Operations"></a>异步vs同步Operations</h2><p>Operations分为同步和异步。创建的operations默认是一个同步的operation。如果你调用<code>start</code>方法启动一个operation，它会在当前线程执行，并且阻塞当前线程直到这个operation结束。另外，你可以把operations放入operation queue中。放入operation queue中的operations会另起一个线程调用<code>start</code>方法，因此会异步执行。当然你可以创建一个异步的operation，这需要重写很多方法，比较麻烦，建议是直接放入operation queue中。</p>
<h2 id="NSOperation的状态"><a href="#NSOperation的状态" class="headerlink" title="NSOperation的状态"></a>NSOperation的状态</h2><p>NSOperation包含了一个状态机来描述每一个操作的执行。</p>
<ul>
<li>isReady 已经准备好执行</li>
<li>isExecuting 正在执行</li>
<li>isFinished  执行成功或取消<br>这三种状态是相互独立的，同时只能是一个状态属性返回YES。这些状态由keypath的KVO通知决定。</li>
</ul>
<h2 id="NSOperation依赖性"><a href="#NSOperation依赖性" class="headerlink" title="NSOperation依赖性"></a>NSOperation依赖性</h2><p>如果某些operation需要按照一定的次序执行。则可以通过<code>addDependency</code>为相应的队列添加依赖。但是在添加依赖的时候要注意依赖循环，从而导致死循环。</p>
<h2 id="NSOperation优先级"><a href="#NSOperation优先级" class="headerlink" title="NSOperation优先级"></a>NSOperation优先级</h2><p>你可以通过operation的<code>queuePriority</code>来设置优先级，从而加快或者延迟queue中的operation的执行。默认的<code>queuePriority</code>是<code>NSOperationQueuePriorityNormal</code>。</p>
<ul>
<li>NSOperationQueuePriorityVeryLow</li>
<li>NSOperationQueuePriorityLow</li>
<li>NSOperationQueuePriorityNormal</li>
<li>NSOperationQueuePriorityHigh</li>
<li>NSOperationQueuePriorityVeryHigh</li>
</ul>
<p>但是priority不能与dependency一起使用。添加了dependency的operation一定严格按照dependency的顺序执行。<br>同时你可以通过operation的<code>qualityOfService</code>来设置系统资源对operation的保障。高保障的operation的优先级大于低保障的operation的优先级。默认的保障等级是NSQualityOfServiceBackground。</p>
<ul>
<li>NSQualityOfServiceUserInteractive</li>
<li>NSQualityOfServiceUserInitiated</li>
<li>NSQualityOfServiceUtility</li>
<li>NSQualityOfServiceBackground</li>
</ul>
<h2 id="NSOperation用法"><a href="#NSOperation用法" class="headerlink" title="NSOperation用法"></a>NSOperation用法</h2><p>首先介绍以下NSBlockOperation和NSInvocationOperation。代码如下：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    NSOperation *blkOperation = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;blk start&quot;);
        [NSThread sleepForTimeInterval:3];
        NSLog(@&quot;blk finished&quot;);
    }];
    blkOperation.queuePriority = NSOperationQueuePriorityHigh;
    blkOperation.qualityOfService = NSQualityOfServiceUserInitiated;
    NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@1,@2]];
    NSOperation *invoOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doSomethingWithArr:) object:arr];
    NSLog(@&quot;question&quot;);
    [queue addOperation:blkOperation];
    blkOperation.completionBlock = ^{
        NSLog(@&quot;haha&quot;);
    };
    [NSThread sleepForTimeInterval:1];
    [blkOperation cancel];
    [queue addOperation:invoOperation];
    [blkOperation waitUntilFinished];
    NSLog(@&quot;answer&quot;);

}

- (void)doSomethingWithArr:(NSMutableArray *)arr {
    NSLog(@&quot;arr is %@ in invo&quot;,arr);

}</code></pre><p>执行结果：</p>
<pre><code>2018-01-05 09:13:31.205077+0800 NSOperationDemo[25280:6903063] question
2018-01-05 09:13:31.205314+0800 NSOperationDemo[25280:6903118] blk start
2018-01-05 09:13:32.206698+0800 NSOperationDemo[25280:6903116] arr is (
1,
2
) in invo
2018-01-05 09:13:34.209701+0800 NSOperationDemo[25280:6903118] blk finished
2018-01-05 09:13:34.209970+0800 NSOperationDemo[25280:6903063] answer
2018-01-05 09:13:34.209981+0800 NSOperationDemo[25280:6903116] haha</code></pre><p>当blkOperation被加入到queue时，这个blkOperation才会被执行。加入queue中的operations是并发执行的。所以invoOperation会同时和blkOperation一起执行。不过由于queue遵循FIFO原则，所以一般会blkOperation先于invoOperation执行。由于blkOperation的<code>cancel</code>在1s后执行，此时由于blkOperation已经在执行，所以无法取消。<code>waitUntilFinished</code>必须是在加入queue后才能执行，不然会死锁。<code>waitUntilFinished</code>后面的代码会在当前operation执行完之后才会执行。<code>completionBlock</code>表示这个opertion执行完之后做的处理。</p>
<p>接下来介绍一下自定义并发的operation。代码如下：</p>
<pre><code>@interface AWOperation() {
BOOL executing;
BOOL finished;
}

@end

@implementation AWOperation

- (instancetype)init {
    if (self = [super init]) {
        executing = NO;
        finished = NO;
    }
    return self;
}

- (void)start {
    if (self.isCancelled) {
        [self willChangeValueForKey:@&quot;isFinished&quot;];
        finished = YES;
        [self didChangeValueForKey:@&quot;isFinished&quot;];
        return;
    }

    [self willChangeValueForKey:@&quot;isExecuting&quot;];
    [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];
    executing = YES;
    [self didChangeValueForKey:@&quot;isExecuting&quot;];
}

- (void)main {
    @try {
        [self willChangeValueForKey:@&quot;isExecuting&quot;];
        executing = NO;
        [self didChangeValueForKey:@&quot;isExecuting&quot;];

        [self willChangeValueForKey:@&quot;isFinished&quot;];
        finished = YES;
        [self didChangeValueForKey:@&quot;isFinished&quot;];
    } @catch (NSException *exception) {
        NSLog(@&quot;Exception: %@&quot;, exception);
    }
}

- (BOOL)isExecuting {
    return executing;
}

- (BOOL)isFinished {
    return finished;
}

- (BOOL)isConcurrent {
    return YES;
}</code></pre><p>对于自定义oepration，<code>start</code>, <code>isExecuting</code>, <code>isFinished</code>, <code>isConcurrent</code>方法是必须实现的。<code>main</code>方法不是必须实现的，但是为了结构清晰，一般会把要做的任务放在main函数中。<br><code>start</code>方法是operation的执行起点。但是当这个operation被cancel掉时，也需要设置operation的状态为finished。对于并发的operation，就是另外启动一个线程来执行main方法，同时<code>isConcurrent</code>方法一直返回YES。<br>另外我们得自己维护operation的状态，同时触发相应的KVO通知。</p>
<h2 id="NSOperation-VS-GCD"><a href="#NSOperation-VS-GCD" class="headerlink" title="NSOperation VS GCD"></a>NSOperation VS GCD</h2><p>NSOperation是对GCD的封装。使用NSOperation也就是在使用GCD。由于NSOperation是更高级的API，因此它拥有更多的功能。</p>
<ul>
<li>依赖性</li>
<li>可观察状态</li>
<li>停止，取消，启动</li>
<li>控制并发</li>
</ul>
<p>虽然苹果建议使用更高级的API，但是如果GCD能够满足要求的话，还是建议用GCD，因为它更轻量。如果需要按照一定顺序执行或者其他高要求的话，可以使用NSOpertation。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/documentation/foundation/operation" target="_blank" rel="noopener">Operation</a><br><a href="https://cocoacasts.com/choosing-between-nsoperation-and-grand-central-dispatch/" target="_blank" rel="noopener">Choosing Between NSOperation and Grand Central Dispatch</a><br><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="noopener">iOS 并发编程之 Operation Queues</a><br><a href="http://blog.devzeng.com/blog/ios-nsoperation-and-nsoperationqueue.html" target="_blank" rel="noopener">iOS多线程之NSOperation和NSOperationQueue</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/GCD%E7%AE%80%E6%9E%90/">GCD简析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Objective-C/">Objective-C</a></span><div class="content"><p>Grand Central Dispatch是一种异步执行任务技术。Dispatch Queue是执行处理的等待队列。它按照追加的顺序(FIFO)执行处理。Dispatch Queue按照是否等待处理可以分为serial Dispatch Queue和Concurrent Dispatch Queue。serial Dispatch Queue中的block只在一个线程中顺序执行，而Concurrent Dispatch Queue中的block会在多个线程中并行执行。<br><img src="http://upload-images.jianshu.io/upload_images/793918-4a72a23fc9dbb9e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="GCD使用简介"><a href="#GCD使用简介" class="headerlink" title="GCD使用简介"></a>GCD使用简介</h2><h3 id="dispatch-queue"><a href="#dispatch-queue" class="headerlink" title="dispatch_queue"></a>dispatch_queue</h3><p><code>dispatch_queue_t</code>可以通过<code>dispatch_queue_create</code>生成自定义队列，也可以使用<code>dispatch_get_global_queue</code>和<code>dispatch_get_main_queue</code>函数来生成全局队列和主队列。<br><code>dispatch_queue_create中</code>的第一个参数<code>label</code>表示queue的名称，<code>attr</code>表示是否是并行队列。<code>dispatch_queue_create</code>创建的队列默认优先级为<code>Default Priority</code>。</p>
<pre><code>dispatch_queue_create(const char *_Nullable label,
    dispatch_queue_attr_t _Nullable attr);</code></pre><p>如果想修改<code>dispatch_queue_create</code>创建的队列的优先级，可以使用<code>dispatch_set_target_queue</code>。</p>
<pre><code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.cmcc.gcdserial&quot;, NULL);
dispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
//设置serialQueue优先级为backgroundQueue的优先级
dispatch_set_target_queue(serialQueue, backgroundQueue);   </code></pre><p>同时在多个<code>serial dispatch Queue</code>中，可以通过设置<code>dispatch_set_target_queue</code>使多个queue串行执行。</p>
<p><code>dispatch_get_global_queue</code>用来创建一个全局队列。第一个参数identifier表示队列的优先级，第二个参数为保留字段。优先级有<code>High Priority</code>、<code>Default Priority</code>、<code>Low Priority</code>、<code>Background Priority</code>4种（在iOS8.0之前）和<code>QOS_CLASS_USER_INTERACTIVE</code>、<code>QOS_CLASS_USER_INITIATED</code>、<code>QOS_CLASS_DEFAULT</code>、<code>QOS_CLASS_UTILITY</code>、<code>QOS_CLASS_UTILITY</code>、<code>QOS_CLASS_UNSPECIFIED</code>5种(iOS8.0及之后)。<br> 全局队列默认都是并发队列。</p>
<pre><code>dispatch_get_global_queue(long identifier, unsigned long flags);</code></pre><p><code>dispatch_get_main_queue</code>用来获得主队列。主队列是一个串行队列。</p>
<pre><code>dispatch_get_main_queue()</code></pre><h3 id="dispatch-async-amp-dispatch-sync"><a href="#dispatch-async-amp-dispatch-sync" class="headerlink" title="dispatch_async &amp; dispatch_sync"></a>dispatch_async &amp; dispatch_sync</h3><p><code>dispatch_async</code>表示异步执行队列，<code>dispatch_sync</code>表示同步执行队列。异步就是不等待处理结果，同步就是等待处理结果。不过对于串行队列，<code>dispatch_async</code>和<code>dispatch_sync</code>效果一样。</p>
<pre><code>__block NSString *serialStr = @&quot;I am serial&quot;;
dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.cmcc.gcdserial&quot;, NULL);
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    dispatch_sync(serialQueue, ^{
        NSLog(@&quot;no.1 %@&quot;,serialStr);
        serialStr = @&quot;I am changed&quot;;
    });
});
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    dispatch_sync(serialQueue, ^{
        NSLog(@&quot;no.2 %@&quot;,serialStr);
    });
});
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    dispatch_sync(serialQueue, ^{
        NSLog(@&quot;no.3 %@&quot;,serialStr);
    });
});</code></pre><p><code>dispatch_sync</code>处理不当容易引起死锁。因此使用时需慎重。比如在主线程中执行以下代码。</p>
<pre><code>dispatch_sync(dispatch_get_main_queue(), ^{
    NSLog(@&quot;I am locked&quot;);
});</code></pre><h3 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h3><p><code>dispatch_after</code>用于延迟一定时间把执行得block加入到队列中。同时这个延时不是精确的，它取决于队列线程runloop，可能会跳过一个runloop周期。</p>
<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3ull * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    NSLog(@&quot;wait at least 3 seconds&quot;);  //3s后追加这block到queue
});</code></pre><h3 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h3><p><code>dispatch_group</code>用于对多个处理全部结束后执行处理结果。group通过<code>dispatch_group_create</code>创建，queue通过<code>dispatch_get_global_queue</code>创建。可以通过<code>dispatch_group_async</code>向group中加入block，或者通过<code>dispatch_group_enter</code>，<code>dispatch_group_leave</code>之间加入block。 <code>dispatch_notify</code>用于前面group中加入的block执行完后通知执行处理结果。<code>dispatch_wait</code>用于等待前面group中加入的block执行。<code>dispatch_wait</code>会阻塞线程，<code>dispatch_notify</code>不会阻塞线程。</p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
__block NSMutableArray *arr = [NSMutableArray arrayWithCapacity:0];
dispatch_group_async(group, queue, ^{
    [arr addObject:@1];
});
dispatch_group_async(group, queue, ^{
    [arr addObject:@2];
});
dispatch_notify(group, queue, ^{
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@&quot;update UI with arr %@&quot;, arr);
    });
});</code></pre><h3 id="dispatch-barrier"><a href="#dispatch-barrier" class="headerlink" title="dispatch_barrier"></a>dispatch_barrier</h3><p>对于数据库和文件的读写，往往希望并行读，同步写。这种情形可以通过<code>dispatch_barrier</code>实现。barrier就像一个栅栏，把queue分为barrier之前和barrier之后。先执行barrier之前的，再执行barrier之中的，最后执行barrier之后的。</p>
<pre><code>__block NSString *barrierStr = @&quot;barrier init&quot;;
dispatch_queue_t barrierqueue = dispatch_queue_create(&quot;com.cmcc.gcdbarrier&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(barrierqueue, ^{
    NSLog(@&quot;read 1 %@&quot;,barrierStr);
});
dispatch_async(barrierqueue, ^{
    NSLog(@&quot;read 2 %@&quot;,barrierStr);
});
dispatch_barrier_async(barrierqueue, ^{
    barrierStr = @&quot;barrier changed&quot;;
    NSLog(@&quot;write 3 %@&quot;,barrierStr);
});
dispatch_async(barrierqueue, ^{
    NSLog(@&quot;read 4 %@&quot;,barrierStr);
});
dispatch_async(barrierqueue, ^{
    NSLog(@&quot;read 5 %@&quot;,barrierStr);
});
dispatch_async(barrierqueue, ^{
    NSLog(@&quot;read 6 %@&quot;,barrierStr);
});</code></pre><h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p><code>dispatch_apply</code>效果与<code>dispatch_group</code>效果类似。但是多了一个次数的参数。</p>
<pre><code>dispatch_apply(6, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
    NSLog(@&quot;%zu&quot;,index);
});
NSLog(@&quot;done&quot;);</code></pre><p>执行结果为:</p>
<pre><code>2018-01-03 12:54:57.690983+0800 GCDDemo[19151:3684607] 2
2018-01-03 12:54:57.690987+0800 GCDDemo[19151:3684605] 1
2018-01-03 12:54:57.690990+0800 GCDDemo[19151:3684608] 3
2018-01-03 12:54:57.690993+0800 GCDDemo[19151:3684670] 5
2018-01-03 12:54:57.690988+0800 GCDDemo[19151:3684509] 4
2018-01-03 12:54:57.690983+0800 GCDDemo[19151:3684606] 0
2018-01-03 12:54:57.692172+0800 GCDDemo[19151:3684509] done</code></pre><h3 id="dispatch-block"><a href="#dispatch-block" class="headerlink" title="dispatch_block"></a>dispatch_block</h3><p>dispatch_block_t是在iOS8及之后引入的，用于监听和取消执行的block。监听通过<code>dispatch_wait</code>和<code>dispatch_notify</code>block的执行。另外通过<code>dispatch_block_cancel</code>来取消执行的block。这个只能取消还没执行的block。</p>
<pre><code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.cmcc.serial&quot;, NULL);
dispatch_block_t block1 = dispatch_block_create(0, ^{
    NSLog(@&quot;start block1&quot;);
    [NSThread sleepForTimeInterval:3];
    NSLog(@&quot;end block1&quot;);
});
dispatch_async(serialQueue, block1);
long result = dispatch_wait(block1, dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC));
if (result == 0) {
    NSLog(@&quot;success perform block1&quot;);
} else {
    NSLog(@&quot;time out&quot;);
}

dispatch_block_t block2 = dispatch_block_create(0, ^{
    NSLog(@&quot;start block2&quot;);
    [NSThread sleepForTimeInterval:3];
    NSLog(@&quot;end block2&quot;);
});
dispatch_async(serialQueue, block2);
dispatch_block_cancel(block1);
dispatch_block_cancel(block2);</code></pre><h3 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h3><p><code>dispatch_semaphore_t</code>表示一个信号量。如果信号量不大于0，<code>dispatch_wait</code>则会阻塞线程。如果用<code>dispatch_semaphore_signal</code>则会为该semaphore增加一个计数。可以用semaphore来做同步操作。</p>
<pre><code>dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
NSMutableArray *array = [NSMutableArray new];
for (int i=0; i&lt;10000; i++) {
    dispatch_async(globalQueue, ^{
        dispatch_wait(semaphore, DISPATCH_TIME_FOREVER);
        [array addObject:[NSNumber numberWithInt:i]];
        NSLog(@&quot;current number is %d&quot;,i);
        dispatch_semaphore_signal(semaphore);
    });
}</code></pre><h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p>dispatch_once是用来创建单例的，它比传统的单例创建比优势是多线程安全的。</p>
<pre><code>static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    //init
});</code></pre><h3 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch_source"></a>dispatch_source</h3><p>Dispatch Source是BSD内核功能<code>kqueue</code>的包装。<code>kqueue</code>是在XNU内核发生各种事件时，在应用程序编程执行处理的方式。<br>Dispatch Source可以处理以下事件：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td>变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td>变量OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td>MACH端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td>MACH端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td>检测到与进程相关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td>可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td>接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td>定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td>文件系统有变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td>可写入文件映像</td>
</tr>
</tbody></table>
<p>下面是GCDAsyncSocket使用<code>DISPATCH_SOURCE_TYPE_READ</code>异步读取文件映像的例子。</p>
<pre><code>//1.创建基于DISPATCH_SOURCE_TYPE_READ的dispatch source
accept4Source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socket4FD, 0, socketQueue);

int socketFD = socket4FD;
dispatch_source_t acceptSource = accept4Source;

__weak IDMPGCDAsyncSocket *weakSelf = self;

//2.指定read事件发生时执行的处理        
dispatch_source_set_event_handler(accept4Source, ^{ @autoreleasepool {
#pragma clang diagnostic push
#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;

    __strong IDMPGCDAsyncSocket *strongSelf = weakSelf;
    if (strongSelf == nil) return_from_block;

    LogVerbose(@&quot;event4Block&quot;);

    unsigned long i = 0;
    unsigned long numPendingConnections = dispatch_source_get_data(acceptSource);

    LogVerbose(@&quot;numPendingConnections: %lu&quot;, numPendingConnections);

    while ([strongSelf doAccept:socketFD] &amp;&amp; (++i &lt; numPendingConnections));

#pragma clang diagnostic pop
}});

//3.指定取消source时执行的处理        
dispatch_source_set_cancel_handler(accept4Source, ^{
#pragma clang diagnostic push
#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;

    #if !OS_OBJECT_USE_OBJC
    LogVerbose(@&quot;dispatch_release(accept4Source)&quot;);
    dispatch_release(acceptSource);
    #endif

    LogVerbose(@&quot;close(socket4FD)&quot;);
    close(socketFD);

#pragma clang diagnostic pop
});

LogVerbose(@&quot;dispatch_resume(accept4Source)&quot;);
//4.启动dispatch source
dispatch_resume(accept4Source);</code></pre><p>下面这个是GCDAsyncSocket使用<code>DISPATCH_SOURCE_TYPE_TIMER</code>的例子。</p>
<pre><code>//1.创建基于DISPATCH_SOURCE_TYPE_TIMER的dispatch source
connectTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, socketQueue);

__weak IDMPGCDAsyncSocket *weakSelf = self;
//2.设置超时时的处理        
dispatch_source_set_event_handler(connectTimer, ^{ @autoreleasepool {
#pragma clang diagnostic push
#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;

    __strong IDMPGCDAsyncSocket *strongSelf = weakSelf;
    if (strongSelf == nil) return_from_block;

    [strongSelf doConnectTimeout];

#pragma clang diagnostic pop
}});

#if !OS_OBJECT_USE_OBJC
dispatch_source_t theConnectTimer = connectTimer;
//3.设置source取消时的处理        
dispatch_source_set_cancel_handler(connectTimer, ^{
#pragma clang diagnostic push
#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;

    LogVerbose(@&quot;dispatch_release(connectTimer)&quot;);
    dispatch_release(theConnectTimer);

#pragma clang diagnostic pop
});
#endif

dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC));
//4.设置定时器超时时间
dispatch_source_set_timer(connectTimer, tt, DISPATCH_TIME_FOREVER, 0);
//5.启动dispatch source
dispatch_resume(connectTimer);</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/documentation/dispatch?language=objc" target="_blank" rel="noopener">Dispatch</a><br><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="noopener">Objective-C高级编程</a><br><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8" target="_blank" rel="noopener">细说GCD（Grand Central Dispatch）如何用</a><br><a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a><br><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入理解GCD</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/Run-Loops/">Run Loops</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/runloop/">runloop</a></span><div class="content"><h2 id="Run-Loops"><a href="#Run-Loops" class="headerlink" title="Run Loops"></a>Run Loops</h2><p>Run loops是线程基础机构中非常重要的一环。它是一个处理事件的循环，帮助你安排事件工作和协调接收到的事件。其目的是在工作时让线程处理，在没工作时让线程休眠。<br>runloop的不是完全自管理的，你必须在适当的时机启动它来处理接收到的事件。你可以使用Cocoa和Core Foundation中的<code>run loop object</code>来配置和管理线程的runloop。你不必手动创建一个runloop，因为包括主线程在内的每个线程都包含一个<code>run loop object</code>。但是你得手动启动子线程的runloop，而主线程的runloop在引用启动时就被启动运行了。</p>
<h2 id="Run-Loop解析"><a href="#Run-Loop解析" class="headerlink" title="Run Loop解析"></a>Run Loop解析</h2><p>runloop的内部是一个do-while循环。它接收两种不同类型的<code>sources</code>(<code>Input sources</code>和<code>Timer sources</code>)分发的事件。<code>Input sources</code>分发异步的事件，<code>Timer sources</code>分发同步的事件。<br><img src="http://upload-images.jianshu.io/upload_images/793918-7a1c57bae5e39608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>此外，在处理sources分发的事件时，runloop同时会产生关于runloop状态的通知。你可以注册runloop observers来接收这些通知。</p>
<h3 id="Run-Loop-Modes"><a href="#Run-Loop-Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h3><p>runloop mode是一个input sources、timers和observers的集合。每次你运行一个runloop时，你必须指定一个mode。同时只有在这个mode中的input sources、timers和observers才能得到处理。<br>每个mode都可以指定一个name用来区分。</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Default</td>
<td>NSDefaultRunLoopMode kCFRunLoopDefaultMode</td>
<td>默认mode，runloop中最常用的mode。</td>
</tr>
<tr>
<td>Connection</td>
<td>NSConnectionReplyMode</td>
<td>用于监测NSConnection对象的回应，很少需要用到。</td>
</tr>
<tr>
<td>Modal</td>
<td>NSModalPanelRunLoopMode</td>
<td>用于识别事件的modal。</td>
</tr>
<tr>
<td>Event tracking</td>
<td>NSEventTrackingRunLoopMode</td>
<td>追踪触摸手势，限制其他接收到的事件，确保界面刷新不会卡顿。</td>
</tr>
<tr>
<td>Common modes</td>
<td>NSRunLoopCommonModes kCFRunLoopCommonModes</td>
<td>常用的modes组合。默认包含default、modal和event tracking modes。</td>
</tr>
<tr>
<td>### Input Sources ###</td>
<td></td>
<td></td>
</tr>
<tr>
<td>input sources包含port-based sources和custom input sources。port-based sources监听应用的Mach ports。custom input sources监听事件的custom sources。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### Port-Based Sources(source1) ####</td>
<td></td>
<td></td>
</tr>
<tr>
<td>在Cocoa中，你只需要使用<code>NSPort</code>来增加port到runloop中。这个port对象会为你处理需要的input sources的创建和配置。在Core Foundation中，你必须通过<code>CFMachPortRef</code>,<code>CFMessagePortRef</code>,<code>CFSocketRef</code>手动创建port和它的runloop source。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### Custom Input Sources(source0) ####</td>
<td></td>
<td></td>
</tr>
<tr>
<td>你需要使用<code>CFRunLoopSourceRef</code>相关的函数来创建一个自定义输入源。你要通过回调函数来配置自定义输入源，从而处理接收到的事件和在从runloop中移除时关闭source。同时你必须定义事件的分发机制。相关的例子可以参考 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3" target="_blank" rel="noopener">Defining a Custom Input Source</a>。它主要处理UIEvent、CFSocket这样的事件。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### Cocoa Perform Selector Sources ####</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cocoa定义了一种自定义输入源，它允许你在任何线程上perform selector。与port-based sources类似，在目标线程上perform selector请求也是连续的，这样减轻了线程中多方法执行的同步问题。与port-based sources不同的是，perform selector在执行后自动从runloop中移除。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>当然，perform selector要想在指定线程中执行，这个线程的runloop必须是启动的。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### Timer Sources ###</td>
<td></td>
<td></td>
</tr>
<tr>
<td>计时器用来通知线程做指定的一些事情。但是计时器的时间不是实时的，有时可能会延后。当这个线程的runloop不在计时器指定的mode中时，那么计时器将会被暂停，直到runloop重新回到计时器指定的mode中去。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### Run Loop Observers ###</td>
<td></td>
<td></td>
</tr>
<tr>
<td>一个计时器或者输入源开始时会给观察者发送通知。runloop中的通知包含以下：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- 进入runloop</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- runloop即将处理计时器</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- runloop即将处理输入源</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- runloop即将进入睡眠</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- runloop被唤醒</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- runloop退出</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="run-loop事件队列"><a href="#run-loop事件队列" class="headerlink" title="run loop事件队列"></a>run loop事件队列</h3><p><img src="http://upload-images.jianshu.io/upload_images/793918-f334b8206fdff786.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="什么时候使用Run-Loop"><a href="#什么时候使用Run-Loop" class="headerlink" title="什么时候使用Run Loop"></a>什么时候使用Run Loop</h2><p>只有当你创建一个子线程时你才需要启动runloop。对于子线程，你需要考虑是否需要启动runloop。比如，你需要执行一些耗时的操作时，就不需要启动runloop。启动runloop是为了能够与线程互动。在以下情况可能需要启动runloop：</p>
<ul>
<li>使用输入源来与其他线程通信</li>
<li>在子线程上使用计时器</li>
<li>使用<code>performselector...</code>方法</li>
<li>需要子线程执行周期性任务</li>
</ul>
<h2 id="Run-Loop实践"><a href="#Run-Loop实践" class="headerlink" title="Run Loop实践"></a>Run Loop实践</h2><h3 id="TableView中实现平滑滚动延迟加载图片"><a href="#TableView中实现平滑滚动延迟加载图片" class="headerlink" title="TableView中实现平滑滚动延迟加载图片"></a>TableView中实现平滑滚动延迟加载图片</h3><p>由于滚动时runloop的current mode是UITrackingRunLoopMode。如果此时图片在加载且较慢的话，会影响runloop的循环，导致滚动卡顿。因此可以利用CFRunLoopMode特性，将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动的时候就不会加载图片，等滚动完current mode切换为NSDefaultRunLoopMode时再加载图片。</p>
<pre><code>UIImage *downloadedImage = ...;
[self.avatarImageView performSelector:@selector(setImage:)
 withObject:downloadedImage
 afterDelay:0
 inModes:@[NSDefaultRunLoopMode]];</code></pre><h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><p>通过分析上面讲过的runloop事件队列，可以发现runloop处理事件主要集中在step3(kCFRunLoopBeforeSources)之后以及step9(kCFRunLoopAfterWaiting)之后。所以可以创建一个observer来观察这两个状态，同时通过semphore来监测这两个状态的处理时间。如果好几次出现大于某个值则认为是出现了UI卡顿。</p>
<pre><code>- (void)startMonitor {
    if (_runLoopObserver) {
        return;
    }
    self.semaphore = dispatch_semaphore_create(0);

    CFRunLoopObserverContext context = {
    0,
    (__bridge void*)self,
    NULL,
    NULL
    };
    _runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context);

    CFRunLoopAddObserver(CFRunLoopGetMain(), _runLoopObserver, kCFRunLoopCommonModes);

    dispatch_async(fluency_monitor_queue(), ^{
        while (YES) {
            long st = dispatch_semaphore_wait(self.semaphore, dispatch_time(DISPATCH_TIME_NOW, 500 * NSEC_PER_MSEC));
            if (st != 0) {
                if (!_runLoopObserver) {
                    _timeoutCount = 0;
                    self.semaphore = 0;
                    self.runLoopActivity = 0;
                    return;
                }

                if (self.runLoopActivity == kCFRunLoopBeforeSources || self.runLoopActivity == kCFRunLoopAfterWaiting) {
                    if (++_timeoutCount &lt; 3) {
                        continue;
                    }
                    //出现了UI卡顿。可以打印堆栈信息看看哪个线程出了问题。

                }
            }
        }
    });
}

static void runLoopObserverCallBack(CFRunLoopObserverRef observer,
                                CFRunLoopActivity activity,
                                void* info) {
    StackMonitor *monitor = (__bridge StackMonitor*)info;
    monitor.runLoopActivity = activity;
    dispatch_semaphore_signal(monitor.semaphore);
}</code></pre><h2 id="Run-Loop源码"><a href="#Run-Loop源码" class="headerlink" title="Run Loop源码"></a>Run Loop源码</h2><p>CFRunLoopRef的代码是开源的，你可以在<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">http://opensource.apple.com/tarballs/CF/</a>里面下载到包含CFRunLoopRef在内的整个CoreFoundation源码。</p>
<p>CFRunLoop结构体如下，包含了对应的线程，modes等。</p>
<pre><code>struct __CFRunLoop {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;            /* locked for accessing mode list */
    __CFPort _wakeUpPort;            // used for CFRunLoopWakeUp
    Boolean _unused;
    volatile _per_run_data *_perRunData;              // reset for runs of the run loop
    pthread_t _pthread;        //runloop对应的线程
    uint32_t _winthread;
    CFMutableSetRef _commonModes;        //所有标记为common的mode集合
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;        //当前运行的mode
    CFMutableSetRef _modes;
    struct _block_item *_blocks_head;
    struct _block_item *_blocks_tail;
    CFAbsoluteTime _runTime;
    CFAbsoluteTime _sleepTime;
    CFTypeRef _counterpart;
};</code></pre><p>RunLoopMode包含了名称和source0、source1、observers、timers的集成等。RunLoop管理RunLoopMode，而RunLoopMode管理具体的事件。</p>
<pre><code>struct __CFRunLoopMode {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;    /* must have the run loop locked before locking this */
    CFStringRef _name;    //mode名称
    Boolean _stopped;    //mode是否被终止
    char _padding[3];
    CFMutableSetRef _sources0;    //source0(custom input source)
    CFMutableSetRef _sources1;    //source1(port-based input source)
    CFMutableArrayRef _observers;    //通知者
    CFMutableArrayRef _timers;    //计时器
    CFMutableDictionaryRef _portToV1SourceMap;    //记录source1port的字典
    __CFPortSet _portSet;
    CFIndex _observerMask;      //观察的runloop的状态
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    dispatch_source_t _timerSource;
    dispatch_queue_t _queue;
    Boolean _timerFired; // set to true by the source when a timer has fired
    Boolean _dispatchTimerArmed;
#endif
#if USE_MK_TIMER_TOO
    mach_port_t _timerPort;
    Boolean _mkTimerArmed;
#endif
#if DEPLOYMENT_TARGET_WINDOWS
    DWORD _msgQMask;
    void (*_msgPump)(void);
#endif
    uint64_t _timerSoftDeadline; /* TSR */
    uint64_t _timerHardDeadline; /* TSR */
};</code></pre><p>CFRunLoopSource结构体如下：</p>
<pre><code>struct __CFRunLoopSource {
    CFRuntimeBase _base;
    uint32_t _bits;
    pthread_mutex_t _lock;
    CFIndex _order;            /* immutable */
    CFMutableBagRef _runLoops;    //添加该source的runloop
    union {
    CFRunLoopSourceContext version0;    /* immutable, except invalidation */
        CFRunLoopSourceContext1 version1;    /* immutable, except invalidation */
    } _context;
};</code></pre><p>CFRunLoopObserver，观察runloop的状态，并抛出回调。</p>
<pre><code>struct __CFRunLoopObserver {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;      //观察的runloop
    CFIndex _rlCount;
    CFOptionFlags _activities;        /* immutable */     //状态
    CFIndex _order;            /* immutable */
    CFRunLoopObserverCallBack _callout;    /* immutable */
    CFRunLoopObserverContext _context;    /* immutable, except invalidation */
};</code></pre><p>CFRunLoopActivity的6种状态。</p>
<pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入run loop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),//即将处理source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//被唤醒但是还没开始处理事件
    kCFRunLoopExit = (1UL &lt;&lt; 7),//run loop已经退出
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};</code></pre><p>CFRunLoopTimer可以在设定的时间点抛出回调，另外它包含了mode集合，因此可以被添加到任何mode中去。</p>
<pre><code>struct __CFRunLoopTimer {
    CFRuntimeBase _base;
    uint16_t _bits;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;    //添加该timer的runloop
    CFMutableSetRef _rlModes;    //mode集合
    CFAbsoluteTime _nextFireDate;    //下一次计时器开始时间
    CFTimeInterval _interval;        /* immutable */    //理想时间间隔
    CFTimeInterval _tolerance;          /* mutable */    //时间偏差
    uint64_t _fireTSR;            /* TSR units */
    CFIndex _order;            /* immutable */
    CFRunLoopTimerCallBack _callout;    /* immutable */
    CFRunLoopTimerContext _context;    /* immutable, except invalidation */
};</code></pre><p>在Core Foundation中通过以下两个API来启动runloop。第一个使用default mode，第二个使用指定的mode。</p>
<ul>
<li><code>void CFRunLoopRun(void)</code></li>
<li><code>SInt32 CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);</code></li>
</ul>
<pre><code>void CFRunLoopRun(void) {    /* DOES CALLOUT */
    int32_t result;
//do-while循环
    do {
        //DefaultMode方式启动CFRunLoopRunSpecific
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(),kCFRunLoopDefaultMode, 1.0e10, false);
    CHECK_FOR_FORK();
    } while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);
}

SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}</code></pre><p>通过源码可知，两种方式内部都是运行了<code>CFRunLoopRunSpecific</code>函数。我们来看一下实现。</p>
<pre><code>SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    //1.如果已经释放掉r1,返回kCFRunLoopRunFinished
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    //2.对r1上锁
    __CFRunLoopLock(rl);
    //3.根据modeName找到当前的mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    //4.如果没有找到或者mode为空，退出runloop
    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) {
    Boolean did = false;
    if (currentMode) __CFRunLoopModeUnlock(currentMode);
    __CFRunLoopUnlock(rl);
    return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);
    //5.取出先前的mode
    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;
    //6.设置当前的mode
    rl-&gt;_currentMode = currentMode;
    //7.初始化一个kCFRunLoopRunFinished的result
    int32_t result = kCFRunLoopRunFinished;
    //8.如果当前_observerMask为kCFRunLoopEntry,通知observer,然后进入__CFRunLoopRun
    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
    //9.如果当前_observerMask为kCFRunLoopExit，通知observer，退出
    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);

        __CFRunLoopModeUnlock(currentMode);
        __CFRunLoopPopPerRunData(rl, previousPerRun);
    rl-&gt;_currentMode = previousMode;
    __CFRunLoopUnlock(rl);
    return result;
}</code></pre><p>由上面的代码可知，mode必须存在，且包含modeItem，这个runloop才能运行。在进入和退出runloop之前通知observer。另外，runloop的核心函数是<code>__CFRunLoopRun</code>。我们来看一下它的逻辑。</p>
<pre><code>static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {
    ........
    //2.通知observer，即将触发计时器回调
    if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);
    //3.通知observer，即将触发source0回调
    if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);
    //执行加入当前runloop的block
__CFRunLoopDoBlocks(rl, rlm);

    //4.处理source0事件
    Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
    if (sourceHandledThisLoop) {
        //执行加入当前runloop的block
        __CFRunLoopDoBlocks(rl, rlm);
    }

    Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);

    if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
        msg = (mach_msg_header_t *)msg_buffer;
        //5.接收dispatchPort端口的source1事件，如果接收到，前往第9步处理msg
        if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) {

            goto handle_msg;
        }
#elif DEPLOYMENT_TARGET_WINDOWS
        if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) {
            goto handle_msg;
        }
#endif
    }

    didDispatchPortLastTime = false;

    //6.通知observer，runloop即将休眠
if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
    //runloop进入休眠
__CFRunLoopSetSleeping(rl);
// do not do any user callouts after this point (after notifying of sleeping)

    // Must push the local-to-this-activation ports in on every loop
    // iteration, as this mode could be run re-entrantly and we don&apos;t
    // want these ports to get serviced.

    __CFPortSetInsert(dispatchPort, waitSet);

__CFRunLoopModeUnlock(rlm);
__CFRunLoopUnlock(rl);

    CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();

#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    //7.do-while循环，用于接收等待端口的消息。
    // • 一个内核端口的source事件
    // • 一个计时器到时间了
    // • RunLoop自身的超时时间到了
    // • 被其他什么调用者手动唤醒
    //满足以上四个条件中一个，退出休眠
    do {
        if (kCFUseCollectableAllocator) {
            // objc_clear_stack(0);
            // &lt;rdar://problem/16393959&gt;
            memset(msg_buffer, 0, sizeof(msg_buffer));
        }
        msg = (mach_msg_header_t *)msg_buffer;

        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);

        if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) {
            // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.
            while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));
            if (rlm-&gt;_timerFired) {
                // Leave livePort as the queue port, and service timers below
                rlm-&gt;_timerFired = false;
                break;
            } else {
                if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
            }
        } else {
            // Go ahead and leave the inner loop.
            break;
        }
    } while (1);
#else
    if (kCFUseCollectableAllocator) {
        // objc_clear_stack(0);
        // &lt;rdar://problem/16393959&gt;
        memset(msg_buffer, 0, sizeof(msg_buffer));
    }
    msg = (mach_msg_header_t *)msg_buffer;
    __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);
#endif

#elif DEPLOYMENT_TARGET_WINDOWS
    // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.
    __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);
#endif

    __CFRunLoopLock(rl);
    __CFRunLoopModeLock(rlm);

    rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));

    // Must remove the local-to-this-activation ports in on every loop
    // iteration, as this mode could be run re-entrantly and we don&apos;t
    // want these ports to get serviced. Also, we don&apos;t want them left
    // in there if this function returns.

    __CFPortSetRemove(dispatchPort, waitSet);

    __CFRunLoopSetIgnoreWakeUps(rl);

    // user callouts now OK again
__CFRunLoopUnsetSleeping(rl);
    //8.通知observer，runloop被唤醒
if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);

    //9.处理接收到的事件
    handle_msg:;
    __CFRunLoopSetIgnoreWakeUps(rl);

#if DEPLOYMENT_TARGET_WINDOWS
    if (windowsMessageReceived) {
        // These Win32 APIs cause a callout, so make sure we&apos;re unlocked first and relocked after
        __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);

        if (rlm-&gt;_msgPump) {
            rlm-&gt;_msgPump();
        } else {
            MSG msg;
            if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) {
                TranslateMessage(&amp;msg);
                DispatchMessage(&amp;msg);
            }
        }

        __CFRunLoopLock(rl);
    __CFRunLoopModeLock(rlm);
     sourceHandledThisLoop = true;

        // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced
        // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we&apos;re just checking to see if the things are signalled right now -- we will wait on them again later.
        // NOTE: Ignore the dispatch source (it&apos;s not in the wait set anymore) and also don&apos;t run the observers here since we are polling.
        __CFRunLoopSetSleeping(rl);
        __CFRunLoopModeUnlock(rlm);
        __CFRunLoopUnlock(rl);

        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &amp;livePort, NULL);

        __CFRunLoopLock(rl);
        __CFRunLoopModeLock(rlm);            
        __CFRunLoopUnsetSleeping(rl);
        // If we have a new live port then it will be handled below as normal
    }

#endif
    if (MACH_PORT_NULL == livePort) {
        CFRUNLOOP_WAKEUP_FOR_NOTHING();
        // handle nothing
    } else if (livePort == rl-&gt;_wakeUpPort) {
        CFRUNLOOP_WAKEUP_FOR_WAKEUP();
        // do nothing on Mac OS
#if DEPLOYMENT_TARGET_WINDOWS
        // Always reset the wake up port, or risk spinning forever
        ResetEvent(rl-&gt;_wakeUpPort);
#endif
    }
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) {
        CFRUNLOOP_WAKEUP_FOR_TIMER();
        if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
            // Re-arm the next timer, because we apparently fired early
            __CFArmNextTimerInMode(rlm, rl);
        }
    }
#endif
#if USE_MK_TIMER_TOO
    //9.1如果计时器时间到了，触发回调
    else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) {
        CFRUNLOOP_WAKEUP_FOR_TIMER();
        // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.
        // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754
        if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
            // Re-arm the next timer
            __CFArmNextTimerInMode(rlm, rl);
        }
    }
#endif
    //9.2如果是dispatch到main_queue的block，执行block
    else if (livePort == dispatchPort) {
        CFRUNLOOP_WAKEUP_FOR_DISPATCH();
        __CFRunLoopModeUnlock(rlm);
        __CFRunLoopUnlock(rl);
        _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);
#if DEPLOYMENT_TARGET_WINDOWS
        void *msg = 0;
#endif
        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
        _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);
        __CFRunLoopLock(rl);
        __CFRunLoopModeLock(rlm);
        sourceHandledThisLoop = true;
        didDispatchPortLastTime = true;
    } else {
        CFRUNLOOP_WAKEUP_FOR_SOURCE();

        // If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.
        voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);

        // Despite the name, this works for windows handles as well
        CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
        if (rls) {
            //9.3如果有source1事件，处理source1事件
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
    mach_msg_header_t *reply = NULL;
    sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;
    if (NULL != reply) {
        (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
        CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
    }
#elif DEPLOYMENT_TARGET_WINDOWS
            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
#endif
    }

        // Restore the previous voucher
        _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);

    }
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
#endif

        //执行加入到loop中的block
    __CFRunLoopDoBlocks(rl, rlm);

    if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
        retVal = kCFRunLoopRunHandledSource;
        } else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) {   //runloop超时
            retVal = kCFRunLoopRunTimedOut;
    } else if (__CFRunLoopIsStopped(rl)) {  //runloop被stop
            __CFRunLoopUnsetStopped(rl);
        retVal = kCFRunLoopRunStopped;
    } else if (rlm-&gt;_stopped) {     //mode被stop
        rlm-&gt;_stopped = false;
        retVal = kCFRunLoopRunStopped;
    } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {     //mode为空
        retVal = kCFRunLoopRunFinished;
    }

#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
        voucher_mach_msg_revert(voucherState);
        os_release(voucherCopy);
#endif
        //如果没超时，mode没空，loop没被停止，继续loop
    } while (0 == retVal);

    if (timeout_timer) {
        dispatch_source_cancel(timeout_timer);
        dispatch_release(timeout_timer);
    } else {
        free(timeout_context);
    }

    return retVal;
}</code></pre><p>其主要执行步骤如下：  </p>
<ol>
<li>通知observer，即将进入runloop。(前面已执行)</li>
<li>通知observer，即将触发计时器回调</li>
<li>通知observer，即将触发source0回调</li>
<li>处理source0事件</li>
<li>接收dispatchPort端口的source1事件，如果接收到，前往第9步处理msg</li>
<li>通知observer，runloop即将休眠</li>
<li>do-while循环，用于接收等待端口的消息来终止休眠<br> 7.1 内核端口的source事件<br> 7.2 计时器到时间了<br> 7.3 RunLoop自身的超时时间到了<br> 7.4 被手动唤醒</li>
<li>通知observer，runloop被唤醒</li>
<li>处理接收到的事件<br> 9.1 如果计时器时间到了，触发回调重新进入循环<br> 9.2 如果是dispatch到main_queue的block(手动唤醒)，执行block<br> 9.3 如果有source1事件，处理source1事件</li>
<li>如果此时runloop超时或者被停止，mode为空或者被停止，则退出循环，否则再次进入步骤2</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要通过源码源码分析了runloop的循环机制以及事件机制。同时介绍了几种runloop的应用场景。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">Run Loops</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="http://aaaboom.com/?p=34" target="_blank" rel="noopener">RunLoop系列之源码分析</a><br><a href="https://allluckly.cn/%E6%8A%95%E7%A8%BF/tougao73" target="_blank" rel="noopener">iOS开发优化篇之卡顿检测</a><br><a href="https://github.com/ming1016/study/wiki/CFRunLoop" target="_blank" rel="noopener">CFRunLoop</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/AutoreleasePool%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">AutoreleasePool与内存管理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Objective-C/">Objective-C</a></span><div class="content"><p>NSAutoreleasePool是一个支持Cocoa引用计数的内存管理系统的对象。</p>
<h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h2><p>自动释放池(autorelease pool)会在消失时向池里的对象发送一条release消息。因此池里的对象会延迟释放直到自动释放池结束（如果这个对象还是retained，还是不会释放）。<br>应用(Application Kit)会在主线程的每个runloop循环开始时创建一个自动释放池，并且在循环结束时结束这个自动释放池。你一般不必创建自己的自动释放池，因为在main函数中已经创建。但是如果你在一个runloop中创建了很多autoreleased对象，你可以自己创建局部的自动释放池来降低内存峰值。</p>
<pre><code>//ARC
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // insert code here...
    }
    return 0;
}</code></pre><p>每一个线程(包括主线程)拥有它自己的NSAutoreleasePool栈。当一给新的pool创建时，它会被放到栈顶。当pools被结束时，它们会从栈中移除。而autoreleased的对象会被放在自动释放池中的顶部。当线程结束时，所有的自动释放池都会自动结束。<br><img src="http://upload-images.jianshu.io/upload_images/793918-f3b9ee50c46d7417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从前面可知，autoreleasePool是由NSRunLoop管理的。但是非主线程的NSRunLoop默认是不开启的，如果产生了autorelease对象，就会调用autoreleaseNoPage方法。它会自动帮你创建一个autoreleasePoolPage，然后push这个对象到autoreleasePoolPage栈中。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理的规则：</p>
<ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>自己持有的对象不再需要时释放。</li>
<li>非自己持有的对象无法释放 。</li>
</ul>
<p><code>__strong</code>修饰符表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。<br>作为<code>alloc/new/copy/mutableCopy</code>方法的返回值而取得对象时，能够自己生成并持有对象。</p>
<pre><code>//ARC有效
{
      // 自己生成并持有对象
      id __strong obj = [NSObject] alloc] init];
      //因为obj为强引用，所以自己持有对象。
}
//因为obj变量超出其作用域，强引用失效。
//所以自动释放自己持有的对象。
//对象的所有者不存在，因此废弃该对象。

-------------------编译器模拟的代码---------------------

id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_release(obj);</code></pre><p><code>__autorelease</code>修饰符等价于ARC无效时调用对象的<code>autorelease</code>方法。一般不用显式的调用。比如使用<code>alloc/new/copy/mutableCopy</code>以外的方法创建对象时，编译器会自动将其返回值的对象注册到autoreleasepool。</p>
<pre><code>@autoreleasepool {
    //取得非自己生成并持有的对象
    id __strong obj = [NSMutableArray array];

    //因为变量obj为强引用，所有自己持有对象。
    //并且该对象由编译器判断其方法名后自动注册到autoreleasepool。
}
//因为变量obj超出其作用域，强引用失效，所以自动释放自己所持有的对象。
//同时虽则@autoreleasepool块的结束，所有对象被自动释放。
//因为对象的所有者不存在，所以废弃其对象。

-------------------编译器模拟的代码---------------------

id obj = objc_msgSend(NSMutableArray, @selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_release(obj);
//objc_retainAutoreleasedReturnValue和objc_autoreleasedReturnValue是成对出现的。</code></pre><p><code>__weak</code>修饰符表示对对象的弱引用，不持有对象实例。并且当该对象被废弃时，弱引用将自动失效且处于nil的状态(与<code>__unsafe_unretained</code>不同)。</p>
<pre><code>//ARC有效
{
    //自己生成并持有对象
    id __strong obj0 = [[NSObject alloc] init];
    //因为obj0为强引用，所以自己持有对象。
    id __weak obj1 = [[NSObject alloc] init];
    //obj1变量持有生成对象的弱引用
}
//因为obj0变量超出其作用域，强引用失效。
//所以自动释放自己持有的对象.
//因为对象的所有者不存在，所以废弃其对象。

-------------------编译器模拟的代码---------------------

id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
id obj1;
objc_initweak(&amp;obj1, obj);
objc_release(obj);
objc_destroyWeak(&amp;obj1);</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool" target="_blank" rel="noopener">NSAutoreleasePool</a><br><a href="https://stackoverflow.com/questions/40993809/why-weak-object-will-be-added-to-autorelease-pool" target="_blank" rel="noopener">Why __weak object will be added to autorelease pool?</a><br><a href="https://www.jianshu.com/p/e3690f3e4675" target="_blank" rel="noopener">引用计数带来的一次讨论</a><br><a href="https://www.jianshu.com/p/f87f40592023" target="_blank" rel="noopener">各个线程 Autorelease 对象的内存管理</a><br><a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">does NSThread create autoreleasepool automaticly now?</a><br><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="noopener">Objective-C高级编程
</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/Block%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Block源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/block/">block</a></span><div class="content"><h2 id="什么是Block"><a href="#什么是Block" class="headerlink" title="什么是Block"></a>什么是Block</h2><p>Block是带有自动变量（局部变量）的匿名函数。Block的内部数据结构如下：</p>
<pre><code>struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};

struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};</code></pre><ul>
<li>isa指针：指向表明该block类型的类。</li>
<li>flags：按bit位表示一些block的附加信息，比如判断block类型、判断block引用计数、判断block是否需要执行辅助函数等。</li>
<li>reserved：保留变量，我的理解是表示block内部的变量数。</li>
<li>invoke：函数指针，指向具体的block实现的函数调用地址。</li>
<li>descriptor：block的附加描述信息，比如保留变量数、block的大小、进行copy或dispose的辅助函数指针。</li>
<li>variables：因为block有闭包性，所以可以访问block外部的局部变量。这些variables就是复制到结构体中的外部局部变量或变量的地址。</li>
</ul>
<h2 id="block类型"><a href="#block类型" class="headerlink" title="block类型"></a>block类型</h2><p>C/C++/OC编译的程序占用内存分布的结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/793918-e0786f35397f1490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>栈区（stack）：由系统自动分配，一般存放函数参数值、局部变量的值等。由编译器自动创建与释放。其操作方式后进先出、先进后出。</li>
<li>堆区（heap）：一般由程序员申请并指明大小，最终也由程序员释放。如果程序员不释放，程序结束时可能会由OS回收。对于堆区的管理是采用链表式管理的，操作系统有一个记录空闲内存地址的链表，当接收到程序分配内存的申请时，操作系统就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后将该节点记录的内存地址分配给程序。</li>
<li>全局区/静态区：全局变量和静态变量存储在这个区域。程序结束后由系统释放。</li>
<li>程序代码区：主要存放函数体的二进制代码。</li>
</ul>
<p>block按照不同的内存区域可以分为：</p>
<ul>
<li><code>_NSConcreteStackBlock</code>，存放在栈区。只用到外部局部变量、成员属性变量，且没有强指针引用的block。<br>StackBlock的生命周期由系统控制的，一旦返回之后，就被系统销毁了。</li>
<li><code>_NSConcreteMallocBlock</code>，存放在堆区。有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock，没有强指针引用即销毁，生命周期由程序员控制。</li>
<li><code>_NSConcreteGlobalBlock</code>， 存放在全局/静态区。没有用到外界变量或只用到全局变量、静态变量的block，生命周期从创建到应用程序结束。</li>
</ul>
<pre><code>int globalNum = 3;
int main(int argc, const char * argv[]) {
    int a = 3;
    NSLog(@&quot;this block is: %@&quot;,^{NSLog(@&quot;I use nothing&quot;);});
    NSLog(@&quot;this block is: %@&quot;,[^{NSLog(@&quot;I use ivar %d&quot;,a);} copy]);
    NSLog(@&quot;this block is: %@&quot;,^{NSLog(@&quot;I use ivar %d&quot;,a);});
    NSLog(@&quot;this block is: %@&quot;,^{NSLog(@&quot;%d&quot;,globalNum);});
    return 0;
}</code></pre><p>其输出结果如下：</p>
<pre><code>2017-12-26 09:01:27.668046+0800 BlockDemo[98660:1165488] this block is: &lt;__NSGlobalBlock__: 0x100001050&gt;
2017-12-26 09:01:27.668246+0800 BlockDemo[98660:1165488] this block is: &lt;__NSMallocBlock__: 0x100507f80&gt;
2017-12-26 09:01:27.668293+0800 BlockDemo[98660:1165488] this block is: &lt;__NSStackBlock__: 0x7fff5fbfefe0&gt;
2017-12-26 09:01:27.668367+0800 BlockDemo[98660:1165488] this block is: &lt;__NSGlobalBlock__: 0x1000010d0&gt;</code></pre><p>注意：在ARC的作用下，block类型通过<code>=</code>进行传递时，会导致<code>objc_retainBlock</code>-&gt;<code>_Block_copy</code>-&gt;<code>_Block_copy_internal</code>方法链，导致<code>__NSStackBlock__</code>类型的block转换为<code>__NSMallocBlock__</code>类型。</p>
<h2 id="block的实现原理"><a href="#block的实现原理" class="headerlink" title="block的实现原理"></a>block的实现原理</h2><p>用clang工具重写为c++代码来探究一下block的内部实现。<br>测试代码如下：</p>
<pre><code>typedef int(^blk)(int);

int globalNum = 3;
int main(int argc, const char * argv[]) {
    int a = 3;
    __block int blockVar = 3;
    static int staticNum = 3;
    blk blk = ^(int count) {
        NSLog(@&quot;a = %d&quot;, a);
        staticNum --;
        globalNum --;
        blockVar --;
        return count * a * globalNum * staticNum;
    };
    a = 10;
    NSLog(@&quot;%d&quot;, blk(1));
    return 0;
}</code></pre><p>clang重写c++后的代码如下：</p>
<pre><code>typedef int(*blk)(int);

int globalNum = 3;
struct __Block_byref_blockVar_0 {
  void *__isa;
  __Block_byref_blockVar_0 *__forwarding;
 int __flags;
 int __size;
 int blockVar;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int a;
  int *staticNum;
  __Block_byref_blockVar_0 *blockVar; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int *_staticNum, __Block_byref_blockVar_0 *_blockVar, int flags=0) : a(_a), staticNum(_staticNum), blockVar(_blockVar-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static int __main_block_func_0(struct __main_block_impl_0 *__cself, int count) {
  __Block_byref_blockVar_0 *blockVar = __cself-&gt;blockVar; // bound by ref
  int a = __cself-&gt;a; // bound by copy
  int *staticNum = __cself-&gt;staticNum; // bound by copy

    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_03_v9qmb8t568sgwcjv8bj5ng380000gn_T_main_6b603d_mi_0, a);
    (*staticNum) --;
    globalNum --;
    (blockVar-&gt;__forwarding-&gt;blockVar) --;
    return count * a * globalNum * (*staticNum);
}
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;blockVar, (void*)src-&gt;blockVar, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;blockVar, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main(int argc, const char * argv[]) {
    int a = 3;
    __attribute__((__blocks__(byref))) __Block_byref_blockVar_0 blockVar = {(void*)0,(__Block_byref_blockVar_0 *)&amp;blockVar, 0, sizeof(__Block_byref_blockVar_0), 3};
    static int staticNum = 3;
    blk blk = ((int (*)(int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, &amp;staticNum, (__Block_byref_blockVar_0 *)&amp;blockVar, 570425344));
    a = 10;
    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_03_v9qmb8t568sgwcjv8bj5ng380000gn_T_main_6b603d_mi_1, ((int (*)(__block_impl *, int))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, 1));
    return 0;
}</code></pre><p>我们看到block其实就是<code>struct __main_block_impl_0</code> 结构体，它由4个成员变量和一个构造函数组成。<br>其中第一个成员变量是<code>__block_impl</code>结构体，指向的是<code>__main_block_func_0</code>函数。<br>第二个成员变量是<code>__main_block_desc_0</code>结构体，负责管理block的内存管理。<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>就是利用OC的runtime进行内存管理。在Block中使用  <code>__strong</code>或者<code>__block</code>修饰符的id类型或对象类型的自动变量时，当block从栈复制到堆时，当对象需要retain的时候调用<code>__main_block_copy</code>方法增加引用计数，当需要释放的时候则调用<code>__main_block_dispose</code>方法释放对象。<br>第三个是int变量。因为block内部引用了外部的自动变量，所以在block结构体中多了一个同类型的成员变量。<br>第四个是捕获到的静态变量。<br>第五个是__block修饰符的变量。具体介绍看下一节。</p>
<p><code>__main_block_func_0</code>包含了block的内部代码。其中包含了一个参数<code>__cself</code>，指向<code>__main_block_impl_0</code>，及匿名block自身。这种写法类似与OC中的方法消息传递。<br>另外可以看到系统加的注释<code>bound by copy</code>，自动变量通过<code>__cself-&gt;val</code>方式捕获。局部变量传入的是值，静态变量传入的是地址。因此局部变量无法更改，而静态变量可以更改。同时全局变量由于作用域大，因此不需要传入就可以自由的在block内部更改。而<code>__block</code>修饰符的变量是通过<code>bound by ref</code>方式被捕获进来的，具体介绍看下一节。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/793918-bcfde0e1e6054d88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="block-修饰符"><a href="#block-修饰符" class="headerlink" title="__block 修饰符"></a>__block 修饰符</h2><p>我们直到，当想要修改block外面的局部变量时，需要用<code>__block</code>修饰符。那么<code>__block</code>的原理是如何的呢。<br>从上面的转换代码中可以看到，带有<code>__block</code>修饰符的局部变量被转换为一个结构体<code>__Block_byref_blockVar_0</code>。这个结构体有5个成员变量。</p>
<ul>
<li>__isa，isa指针<ul>
<li>__forwarding，指向自身类型的指针</li>
<li>__flags，标记</li>
<li>__size，结构体大小</li>
<li>__blockVar，局部变量</li>
</ul>
</li>
</ul>
<pre><code>struct __Block_byref_blockVar_0 {
  void *__isa;
  __Block_byref_blockVar_0 *__forwarding;
  int __flags;
  int __size;
  int blockVar;
};</code></pre><p>从代码中我们可以看到<code>blockVar-&gt;__forwarding-&gt;blockVar</code>这样的方式来对<code>__block</code>修饰的变量进行操作，但是为什么要搞这么复杂呢？<br><code>__forwarding</code> 指针就是针对堆里的block。把原来指向自己的<code>__forwarding</code>指针指向堆上的<code>__block</code>变量。然后堆上的变量的<code>__forwarding</code>指向自己。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/793918-55b2b99d005e487c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/793918-9bb911e06153a546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="Block中的循环引用"><a href="#Block中的循环引用" class="headerlink" title="Block中的循环引用"></a>Block中的循环引用</h2><p>循环引用，就是相互引用。比如A强引用B，B又强引用A。那么A和B的引用计数永远无法为0，造成内存泄漏。当然这种循环也可以是多个对象间的。<br><img src="http://upload-images.jianshu.io/upload_images/793918-92ceef58c2d952e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>而对于block的循环引用，一般是一个对象引用block，而block内部又引用了这个对象。<br>打破这种循环引用一般有两种方法：1.弱引用；2.主动释放<br><img src="http://upload-images.jianshu.io/upload_images/793918-ef44b54ef0f8ee64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><pre><code>__weak typeof(self) weakSelf = self;
self.blk = ^{
    NSLog(@&quot;%@&quot;,weakSelf);
};</code></pre><h3 id="主动释放"><a href="#主动释放" class="headerlink" title="主动释放"></a>主动释放</h3><pre><code>__block id blockSelf = self;
self.blk = ^{
    NSLog(@&quot;%@&quot;,blockSelf);
    blockSelf = nil;
};
self.blk();</code></pre><p>当然，弱引用和主动释放各有缺点：<br>主动释放的缺点：</p>
<ul>
<li>必须执行block才能避免循环引用</li>
</ul>
<p>弱引用的缺点：</p>
<ul>
<li>不能保证self对象是否已经被销毁</li>
</ul>
<p>当然对于弱引用，可以利用weak-strong-dance来保证不会出现因为self释放引起问题。</p>
<pre><code>__weak typeof(self) weakSelf = self;
self.blk = ^{
    __strong typeof(weakSelf) strongSelf = weakSelf;
    NSLog(@&quot;%@&quot;,strongSelf);
};</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/ee9756f3d5f6" target="_blank" rel="noopener">1.深入研究Block捕获外部变量和__block实现原理</a><br><a href="https://www.jianshu.com/p/f0cd09a04a36" target="_blank" rel="noopener">2.老司机出品——源码解析之从Block说开去</a><br><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/" target="_blank" rel="noopener">3.A look inside blocks: Episode 1</a><br><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/" target="_blank" rel="noopener">4.A look inside blocks: Episode 2</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">SDWebImage源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Objective-C/">Objective-C</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><div class="content"><p>SDWebImage库是一个支持缓存的异步图片下载库。为了方便使用，它提供了UIImageView, UIButton, MKAnnotationView等UI组件的分类。它的优点包含以下：</p>
<ul>
<li>异步图片下载器</li>
<li>异步的内存+磁盘图片缓存，自动缓存过期处理</li>
<li>后台图片解压</li>
<li>同一个URL不会多次下载的保证机制</li>
<li>错误的URL不会多次尝试的保证机制</li>
<li>主线程不会被block的保证机制</li>
<li>良好的性能</li>
<li>使用GCD和ARC</li>
</ul>
<p>下面以UIImageView为例，讲一下获取图片的流程。</p>
<ol>
<li>首先UIImageView调用sd_setImageWithURL来获得图片。</li>
<li>这个接口的内部调用UIView+webCache分类的sd_internalSetImageWithURL。</li>
<li>sd_internalSetImageWithURL这个方法内部调用SDWebImageManager的loadImageWithURL方法。</li>
<li>SDWebImageManager是一个总的管理类。它首先通过SDWebImageCache的queryCacheOperationForKey去检查图片的缓存是否存在。</li>
<li>如果存在就直接返回图片给最外层。</li>
<li>如果不存在就会用SDWebImageDownloader中的downloadImageWithURL方法去下载图片。下载完成后首先通过SDWebImageCache来缓存图片，再返回图片给最外层。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/793918-d091a52e74aa24ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sdwebimage.png"></p>
<h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><pre><code>- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url
                                          options:(SDWebImageOptions)options
                                         progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock
                                        completed:(nullable SDInternalCompletionBlock)completedBlock;</code></pre><p>SDWebImageManager是一个管理类，管理从缓存获取图片和downloader下载图片。</p>
<ul>
<li>它是一个单例。</li>
<li>它维护了SDImageCache的单例，用来获取缓存</li>
<li>它维护了SDWebImageDownloader的单例，用来下载图片。</li>
<li>它维护了一个failedURLs黑名单，如果URL在黑名单中，则会取消操作。</li>
<li>它维护了一个runingOperation的数组，可以取消和增加operation。</li>
</ul>
<h2 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h2><pre><code>- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock;</code></pre><p>SDImageCache是一个缓存管理类，管理NSCache和disk中的缓存。它首先从NSCache中获取缓存，获取不到再从disk中获取。</p>
<ul>
<li><p>NSCache是一个线程安全的类，在系统内存不足的情况下默认会自动释放部分内存。它的用法和NSMutableDictionary类似。</p>
</li>
<li><p>NSCache中找不到，就会另起一个线程去从disk中获取图片。文件名以url的16位md5后的字符串，然后每一位字符转换为16进制数命名，防止文件名冲突。</p>
<pre><code>- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key {
   const char *str = key.UTF8String;
   if (str == NULL) {
      str = &quot;&quot;;
   }
   unsigned char r[CC_MD5_DIGEST_LENGTH];
   CC_MD5(str, (CC_LONG)strlen(str), r);
   NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,
                    r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],
                    r[11], r[12], r[13], r[14], r[15], [key.pathExtension isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, key.pathExtension]];

   return filename;
}</code></pre></li>
<li><p>它可以对所有的缓存整体操作，清理内存缓存和磁盘缓存。而且通过NSNotification注册内存警告，关闭，后台事件，会自动清理过期缓存。事件默认是1周，大小默认没有限制。</p>
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(clearMemory)
                                             name:UIApplicationDidReceiveMemoryWarningNotification
                                           object:nil];

[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(deleteOldFiles)
                                             name:UIApplicationWillTerminateNotification
                                           object:nil];

[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(backgroundDeleteOldFiles)
                                             name:UIApplicationDidEnterBackgroundNotification
                                           object:nil];</code></pre></li>
</ul>
<h2 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h2><pre><code>- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url
                                               options:(SDWebImageDownloaderOptions)options
                                              progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock
                                             completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</code></pre><ul>
<li>它是一个单例。<ul>
<li>它维护了一个downloadQueue(NSOperationQueue)，最大并发数为6，默认先进先出。</li>
</ul>
</li>
</ul>
<pre><code>- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration {
if ((self = [super init])) {
    _operationClass = [SDWebImageDownloaderOperation class];
    _shouldDecompressImages = YES;
    _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;
    _downloadQueue = [NSOperationQueue new];
    _downloadQueue.maxConcurrentOperationCount = 6;
    _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;
    _URLOperations = [NSMutableDictionary new];
#ifdef SD_WEBP
    _HTTPHeaders = [@{@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;} mutableCopy];
#else
    _HTTPHeaders = [@{@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;} mutableCopy];
#endif
    _barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
    _downloadTimeout = 15.0;

    sessionConfiguration.timeoutIntervalForRequest = _downloadTimeout;

    /**
     *  Create the session for this task
     *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate
     *  method calls and completion handler calls.
     */
    self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration
                                                 delegate:self
                                            delegateQueue:nil];
     }
     return self;
}</code></pre><ul>
<li><p>它维护了一个URLOperations字典，以URL为key，operation为value，从而确保同一个URL不会多次下载。同时通过dispatch_barrier_sync来同步执行下载操作。</p>
<pre><code>- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock
                                     completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock
                                             forURL:(nullable NSURL *)url
                                     createCallback:(SDWebImageDownloaderOperation *(^)())createCallback {
// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.
if (url == nil) {
  if (completedBlock != nil) {
      completedBlock(nil, nil, nil, NO);
  }
  return nil;
}

__block SDWebImageDownloadToken *token = nil;

dispatch_barrier_sync(self.barrierQueue, ^{
  SDWebImageDownloaderOperation *operation = self.URLOperations[url];
  if (!operation) {
      operation = createCallback();
      self.URLOperations[url] = operation;

      __weak SDWebImageDownloaderOperation *woperation = operation;
      operation.completionBlock = ^{
        SDWebImageDownloaderOperation *soperation = woperation;
        if (!soperation) return;
        if (self.URLOperations[url] == soperation) {
            [self.URLOperations removeObjectForKey:url];
        };
      };
  }
  id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];

  token = [SDWebImageDownloadToken new];
  token.url = url;
  token.downloadOperationCancelToken = downloadOperationCancelToken;
});

return token;
}</code></pre></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/iOS%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81/">iOS中常见的锁</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%94%81/">锁</a></span><div class="content"><p>锁一般用于在多线程中，保证在一段时期内这段代码只能被某一个线程所访问，从而保证线程同步。在iOS中，常用的锁大致有@synchronized,NSLock,NSCondition,NSConditionLock、NSRecursiveLock和dispatch_semaphore等，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/793918-e4ae4337fbf77d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="常见锁介绍"><a href="#常见锁介绍" class="headerlink" title="常见锁介绍"></a>常见锁介绍</h2><p>锁按照功能分，主要可以分为互斥锁，自旋锁，信号量。</p>
<ul>
<li>互斥锁禁止多个线程同时进入受保护的代码“临界区”（critical section）。</li>
<li>自旋锁跟互斥锁一样，但是获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。</li>
<li>信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3>@synchronized(obj)指令使用的obj为该锁的唯一标识，同一标识的线程互斥。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。@synchronized的内部详细原理可以参考<a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener" title="关于 @synchronized，这儿比你想知道的还要多">关于 @synchronized，这儿比你想知道的还要多</a>。</li>
</ul>
<pre><code>NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1,@2, nil];

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    sleep(1);
    @synchronized(arr) {
        [arr removeLastObject];
        sleep(1);
        NSLog(@&quot;%lu in thread1&quot;,arr.count);

    }
});

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    @synchronized(arr) {
        @synchronized(arr) {
            [arr removeLastObject];
            NSLog(@&quot;%lu in thread2&quot;,arr.count);
            sleep(2);
        }
    }
});</code></pre><p>输出结果如下：</p>
<pre><code>2017-12-20 14:55:19.646387+0800 Lock[49276:6948973] 1 in thread2
2017-12-20 14:55:22.653366+0800 Lock[49276:6948972] 0 in thread1</code></pre><h3 id="NSConditon"><a href="#NSConditon" class="headerlink" title="NSConditon"></a>NSConditon</h3><p>NSConditon是一种条件锁。当其他线程的锁收到signal（单发）或者broadcast（多发）时，如果条件为true，则会上锁。</p>
<pre><code>NSCondition *lock = [[NSCondition alloc] init];
NSMutableArray *array = [[NSMutableArray alloc] init];

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    [lock lock];
    while (!array.count) {
        [lock wait];
    }
    [array removeLastObject];
    NSLog(@&quot;remove last object %@&quot;,array);
    [lock unlock];
});

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    [lock lock];
    while (!array.count) {
        [lock wait];
    }
    [array removeLastObject];
    NSLog(@&quot;remove last object %@&quot;,array);
    [lock unlock];
});

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    sleep(1);
    [lock lock];
    [array addObjectsFromArray:@[@1,@2]];
    NSLog(@&quot;add objects @1,@2&quot;);
    [lock broadcast];
    [lock unlock];
});
}</code></pre><p>输出如下：</p>
<pre><code>2017-12-20 15:09:27.322078+0800 Lock[67589:7008671] add objects @1,@2
2017-12-20 15:09:27.322539+0800 Lock[67589:7008668] remove last object (
1
)
2017-12-20 15:09:27.322731+0800 Lock[67589:7008669] remove last object (
)</code></pre><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><p>NSConditionLock这种条件锁在初始化时可以指定一个条件，在上锁时，只有满足这个条件才能上锁，在解锁时，可以修改这个条件锁的条件。</p>
<pre><code>NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:1];

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    [lock lockWhenCondition:0];
    NSLog(@&quot;locked this lock in thread 1&quot;);
    sleep(1);
    [lock unlock];
});

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    sleep(2);
    if ([lock tryLockWhenCondition:1]) {
        NSLog(@&quot;locked this lock in thread 2&quot;);
        sleep(1);
        [lock unlockWithCondition:0];
        NSLog(@&quot;unlocked this lock in thread 2&quot;);
    } else {
        NSLog(@&quot;fail locked this lock in thread 2&quot;);
    }
});</code></pre><p>输出如下：</p>
<pre><code>2017-12-20 15:16:32.725752+0800 Lock[76697:7037383] locked this lock in thread 2
2017-12-20 15:16:33.726779+0800 Lock[76697:7037383] unlocked this lock in thread 2
2017-12-20 15:16:33.726803+0800 Lock[76697:7037384] locked this lock in thread 1</code></pre><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h3><p>递归锁用在需要递归的地方。这种锁不会因为重复上锁而导致死锁。</p>
<pre><code>NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    static void (^recursiveBlock)(int);
    recursiveBlock = ^(int value) {
        [lock lock];
        if (value &gt; 0) {
            NSLog(@&quot;value is %d&quot;,value);
            recursiveBlock(value-1);
        }
        [lock unlock];
    };
    recursiveBlock(5);
});</code></pre><p>输出如下：</p>
<pre><code>2017-12-20 15:21:09.465255+0800 Lock[82850:7057130] value is 5
2017-12-20 15:21:09.465562+0800 Lock[82850:7057130] value is 4
2017-12-20 15:21:09.465739+0800 Lock[82850:7057130] value is 3
2017-12-20 15:21:09.465906+0800 Lock[82850:7057130] value is 2
2017-12-20 15:21:09.466064+0800 Lock[82850:7057130] value is 1</code></pre><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><p>使用方法非常简单，dispatch_semaphore_create(1)为创建信号，数字表示可以同时几个线程使用信号。为1表示同步使用。如果此处标2就和没设置信号量一样，并发自行运行。如果设置为0，则一律等待overTime时自动释放，所有代码都不执行，理论上也具有同步作用，就是慢点…</p>
<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);
dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 3.0f * NSEC_PER_SEC);

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;线程1 等待ing&quot;);
    dispatch_semaphore_wait(signal, timeout); //signal 值 -1
    NSLog(@&quot;线程1 sleep&quot;);
    sleep(2);
    NSLog(@&quot;线程1&quot;);
    dispatch_semaphore_signal(signal); //signal 值 +1
    NSLog(@&quot;线程1 发送信号&quot;);
});

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;线程2 等待ing&quot;);
    dispatch_semaphore_wait(signal, timeout);
    NSLog(@&quot;线程2 sleep&quot;);
    sleep(2);
    NSLog(@&quot;线程2&quot;);
    dispatch_semaphore_signal(signal);
    NSLog(@&quot;线程2 发送信号&quot;);
});</code></pre><p>输出如下：</p>
<pre><code>2017-12-20 16:28:19.286668+0800 Lock[70914:7323787] 线程2 等待ing
2017-12-20 16:28:19.286670+0800 Lock[70914:7323790] 线程1 等待ing
2017-12-20 16:28:19.286810+0800 Lock[70914:7323787] 线程2 sleep
2017-12-20 16:28:21.290357+0800 Lock[70914:7323787] 线程2
2017-12-20 16:28:21.290556+0800 Lock[70914:7323787] 线程2 发送信号
2017-12-20 16:28:21.290566+0800 Lock[70914:7323790] 线程1 sleep
2017-12-20 16:28:23.294412+0800 Lock[70914:7323790] 线程1
2017-12-20 16:28:23.294572+0800 Lock[70914:7323790] 线程1 发送信号</code></pre><h2 id=""><a href="#" class="headerlink" title="##"></a>##</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/iOS%E4%B8%AD%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/">iOS中触摸事件的传递和响应机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%93%8D%E5%BA%94%E8%BF%9E/">响应连</a></span><div class="content"><p>所有继承响应者对象UIResponder都能接收并处理事件。按照时间顺序，先找到到最合适的view，然后就会调用view的touches方法，这些方法的默认做法是将事件顺着响应这链条向上传递，将事件交由上一个响应者进行处理，直到有一个view能处理该响应为止或者丢弃。这是一个从上到下，再从下到上的过程。</p>
<h3 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h3><ul>
<li>发生事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>
<li>UIApplication会从事件队列中取出最前面的事件，并将该事件分发下去处理。通常，先发送事件给应用程序的主窗口（keywindow）。</li>
<li>keywindow会在视图层次结构中找到一个最合适的视图来处理事件。</li>
</ul>
<h3 id="事件的传递"><a href="#事件的传递" class="headerlink" title="事件的传递"></a>事件的传递</h3><p>事件的传递先从父控件传递到子控件（UIApplication-&gt;window-&gt;寻找处理事件最合适的view）。<br>如果父view不能接受触摸事件，那么子view也不能接收到触摸事件。</p>
<h4 id="如何找到最合适的view来处理事件"><a href="#如何找到最合适的view来处理事件" class="headerlink" title="如何找到最合适的view来处理事件"></a>如何找到最合适的view来处理事件</h4><ol>
<li>判断keywindow自己是否接受事件</li>
<li>判断事件是否在自己身上</li>
<li>子view数组中从后往前遍历子控件，重复前面1,2步骤</li>
<li>如果没有合适的子控件，那自己就是最合适的控件</li>
</ol>
<h4 id="寻找最合适的view底层剖析"><a href="#寻找最合适的view底层剖析" class="headerlink" title="寻找最合适的view底层剖析"></a>寻找最合适的view底层剖析</h4><p>有两个重要的方法：</p>
<pre><code>hitTest:withEvent:
pointInside:withEvent:</code></pre><p>view会调用hitTest:withEvent:方法，hitTest:withEvent:方法底层会调用pointInside:withEvent:方法判断触摸点是不是在这个view的坐标系上。如果在坐标系上，会分发事件给这个view的子view。然后每个字view重复以上步骤，直至最底层的一个合适的view。</p>
<h3 id="事件的响应"><a href="#事件的响应" class="headerlink" title="事件的响应"></a>事件的响应</h3><p>事件响应会先从底层最合适的view开始，然后随着上一步找到的链一层一层响应touch事件。默认touch事件会传递给上一层。如果到了viewcontroller的view，就会传递给viewcontroller。如果viewcontroller不能处理，就会传递给UIWindow。如果UIWindow无法处理，就会传递给UIApplication。如果UIApplication无法处理，就会传递给UIApplicationDelegate。如果UIApplicationDelegate不能处理，则会丢弃该事件。<br><img src="http://upload-images.jianshu.io/upload_images/793918-96612e4b561ab6ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/iOS%E4%B9%8B%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86/">iOS之集合遍历</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/iOS/">iOS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Objective-C/">Objective-C</a></span><div class="content"><p> 在iOS编程中，经常需要列举collection中的元素，当前的Objective-C中有如下几种方法：</p>
<ol>
<li>标准的c语言循环</li>
<li>NSEnumerator</li>
<li>fast enumeration</li>
<li>block enumeration</li>
</ol>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>接下来以NSSet为例测试一下4种方法的性能。代码如下：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

#define magicNum 1000000

int main(int argc, const char * argv[]) {
NSMutableSet *mutableSet = [NSMutableSet setWithCapacity:0];
for (int i=1; i&lt;=magicNum; i++) {
    NSNumber *temp= [NSNumber numberWithInteger:i];
    [mutableSet addObject:temp];
}
NSSet *set = [mutableSet copy];

CFAbsoluteTime startTime1 =CFAbsoluteTimeGetCurrent();
NSArray *tempArr = [set allObjects];
for (int i=0; i &lt; tempArr.count; i++) {
    if (![tempArr[i] isEqualToNumber:[NSNumber numberWithInteger:magicNum]]) {
        continue;
    }
    NSLog(@&quot;%@&quot;,tempArr[i]);
    break;
}
CFAbsoluteTime linkTime1 = (CFAbsoluteTimeGetCurrent() - startTime1);
NSLog(@&quot;Linked1 in %f ms&quot;, linkTime1 *1000.0);

CFAbsoluteTime startTime2 =CFAbsoluteTimeGetCurrent();
NSEnumerator *enumerator = [set objectEnumerator];
id obj;
while (obj = [enumerator nextObject]) {
    if (![obj isEqualToNumber:[NSNumber numberWithInteger:magicNum]]) {
        continue;
    }
    NSLog(@&quot;%@&quot;,obj);
    break;
}
CFAbsoluteTime linkTime2 = (CFAbsoluteTimeGetCurrent() - startTime2);
NSLog(@&quot;Linked2 in %f ms&quot;, linkTime2 *1000.0);

CFAbsoluteTime startTime3 =CFAbsoluteTimeGetCurrent();
for (NSNumber *number in set) {
    if (![number isEqualToNumber:[NSNumber numberWithInteger:magicNum]]) {
        continue;
    }
    NSLog(@&quot;%@&quot;,number);
    break;
}
CFAbsoluteTime linkTime3 = (CFAbsoluteTimeGetCurrent() - startTime3);
NSLog(@&quot;Linked3 in %f ms&quot;, linkTime3 *1000.0);

CFAbsoluteTime startTime4 =CFAbsoluteTimeGetCurrent();
[set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) {
    if ([obj isEqualToNumber:[NSNumber numberWithInteger:magicNum]]) {
        NSLog(@&quot;%@&quot;,obj);
        *stop = YES;
    }
}];
CFAbsoluteTime linkTime4 = (CFAbsoluteTimeGetCurrent() - startTime4);
NSLog(@&quot;Linked4 in %f ms&quot;, linkTime4 *1000.0);
return 0;
}</code></pre><p>通过测试发现，fast enumeration耗时最少，block enumeration耗时最多。标准c语言循环耗时也比较多，而且对于无序集合，需要先copy到一个数组中，增加了额外开销。而且容易产生<a href="http://en.wikipedia.org/wiki/Off-by-one_error" target="_blank" rel="noopener">off-by-one errors</a>。block enumeration虽然耗时比较多，但是对于需要用到block的地方，这个方法比较便捷。</p>
<pre><code>2017-12-17 19:58:34.006923+0800 FastEnumerationDemo[39073:785059] 1000000
2017-12-17 19:58:34.007785+0800 FastEnumerationDemo[39073:785059] Linked1 in 77.924013 ms
2017-12-17 19:58:34.069683+0800 FastEnumerationDemo[39073:785059] 1000000
2017-12-17 19:58:34.069718+0800 FastEnumerationDemo[39073:785059] Linked2 in 61.906993 ms
2017-12-17 19:58:34.125608+0800 FastEnumerationDemo[39073:785059] 1000000
2017-12-17 19:58:34.125817+0800 FastEnumerationDemo[39073:785059] Linked3 in 56.064010 ms
2017-12-17 19:58:34.210177+0800 FastEnumerationDemo[39073:785059] 1000000
2017-12-17 19:58:34.210214+0800 FastEnumerationDemo[39073:785059] Linked4 in 84.289968 ms</code></pre><h3 id="为什么fast-enumeration性能最优？"><a href="#为什么fast-enumeration性能最优？" class="headerlink" title="为什么fast enumeration性能最优？###"></a>为什么fast enumeration性能最优？###</h3><p>Objective-C 2.0引入了快速遍历的功能，它为for循环开设了in关键字。只要实现了 NSFastEnumeration protocol的类都能够快速遍历，包括NSDictionary, NSArray, NSSet等。</p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1<NSFastEnumeration protocol></h4><p>NSFastEnumeration只包含了一个方法：</p>
<pre><code>/**
Returns by reference a C array of objects over which the sender should iterate, and as the return value the number of objects in the array.

@param state  Context information that is used in the enumeration to, in addition to other possibilities, ensure that the collection has not been mutated.
@param buffer A C array of objects over which the sender is to iterate.
@param len    The maximum number of objects to return in stackbuf.

@discussion The state structure is assumed to be of stack local memory, so you can recast the passed in state structure to one more suitable for your iteration.

@return The number of objects returned in stackbuf. Returns 0 when the iteration is finished.
*/
- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len;</code></pre><p>NSFastEnumerationState结构体如下：</p>
<pre><code>typedef struct {
  unsigned long state;
  id *itemsPtr;
  unsigned long *mutationsPtr;
  unsigned long extra[5];
} NSFastEnumerationState;</code></pre><p>这个方法就是返回一系列C数组，以供调用者进行遍历。C数组需要提供一个数组的指针和数组的长度。数组的长度就是这个函数的返回值，数组的指针就是NSFastEnumerationState中的itemsPtr。<br>当然，有些数据结构不是连续内存的，这时需要把它拷贝到一个C数组上，就是buffer参数，长度由len决定。<br>如果集合在遍历的过程中被修改的话，NSFastEnumeration 就会抛出异常。而这个功能就是通过 mutationsPtr 字段来实现的，它指向一个这样的值，这个值在集合被修改时会发现改变。因此，我们就可以利用它来判断集合在遍历的过程中是否被修改。</p>
<h5 id="fast-enumeration内部实现"><a href="#fast-enumeration内部实现" class="headerlink" title="fast enumeration内部实现"></a>fast enumeration内部实现</h5><p>用clang命令将代码重写为C++代码。</p>
<pre><code>clang rewrite-objc main.m</code></pre><p>代码如下：</p>
<pre><code>{
NSNumber * number;
struct __objcFastEnumerationState enumState = { 0 };
id __rw_items[16];
id l_collection = (id) set;
_WIN_NSUInteger limit =
    ((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend)
    ((id)l_collection,
    sel_registerName(&quot;countByEnumeratingWithState:objects:count:&quot;),
    &amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16);
if (limit) {
unsigned long startMutations = *enumState.mutationsPtr;
do {
    unsigned long counter = 0;
    do {
        if (startMutations != *enumState.mutationsPtr)
            objc_enumerationMutation(l_collection);
        number = (NSNumber *)enumState.itemsPtr[counter++]; {
    if (!((BOOL (*)(id, SEL, NSNumber *))(void *)objc_msgSend)((id)number, sel_registerName(&quot;isEqualToNumber:&quot;), ((NSNumber *(*)(id, SEL, NSInteger))(void *)objc_msgSend)((id)objc_getClass(&quot;NSNumber&quot;), sel_registerName(&quot;numberWithInteger:&quot;), (NSInteger)1000000))) {
        goto __continue_label_1;
    }
    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_0c_dkz7xg955s35wk657wvq8y8w0000gn_T_main_af2091_mi_4,number);
    goto __break_label_1;
};
__continue_label_1: ;
    } while (counter &lt; limit);
} while ((limit = ((_WIN_NSUInteger (*) (id, SEL, struct __objcFastEnumerationState *, id *, _WIN_NSUInteger))(void *)objc_msgSend)
    ((id)l_collection,
    sel_registerName(&quot;countByEnumeratingWithState:objects:count:&quot;),
    &amp;enumState, (id *)__rw_items, (_WIN_NSUInteger)16)));
number = ((NSNumber *)0);
__break_label_1: ;
}
else
    number = ((NSNumber *)0);
}</code></pre><p>可以看到，里面用到了两个do-while循环。外层负责调用 countByEnumeratingWithState:objects:count:方法，获取C数组。内层则负责遍历C数组。在内层遍历中，使用指针的算术运算获取相应的集合元素，这是快速枚举之所以高效的关键所在。</p>
<pre><code>number = (NSNumber *)enumState.itemsPtr[counter++]</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文首先分析了各种集合遍历的性能，然后对fast enumeration做了性能的内部剖析。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html" target="_blank" rel="noopener">Mike Ash has a fantastic blog post</a><br>2.<a href="http://blog.leichunfeng.com/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle/" target="_blank" rel="noopener">Objective-C Fast Enumeration 的实现原理</a><br>3.<a href="http://nshipster.com/enumerators/" target="_blank" rel="noopener">NSFast​Enumeration / NSEnumerator</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/29/Hadoop%E5%9C%A8YARN%E4%B8%8A%E7%9A%84%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85-Mac/">Hadoop在YARN上的伪分布式安装(Mac)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Hadoop/">Hadoop</a></span><div class="content"><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>电脑上已经安装了SSH，Homebrew，JDK8。</p>
<h3 id="配置SSH无密码登录自己电脑"><a href="#配置SSH无密码登录自己电脑" class="headerlink" title="配置SSH无密码登录自己电脑"></a>配置SSH无密码登录自己电脑</h3><p>在终端执行以下命令：</p>
<pre><code>$ ssh localhost</code></pre><p>如果需要输入密码登录，则执行以下命令：</p>
<pre><code>$ ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_rsa
$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
$ chmod 0600 ~/.ssh/authorized_keys</code></pre><p>再次输入ssh localhost则应该可以不用密码就可以登录</p>
<h3 id="用homebrew安装hadoop"><a href="#用homebrew安装hadoop" class="headerlink" title="用homebrew安装hadoop"></a>用homebrew安装hadoop</h3><p>执行以下命令来安装hadoop:</p>
<pre><code>$ brew install apache-hadoop</code></pre><p>则会安装最新的hadoop版本。</p>
<h3 id="伪分布式配置hadoop"><a href="#伪分布式配置hadoop" class="headerlink" title="伪分布式配置hadoop"></a>伪分布式配置hadoop</h3><p>进入 /usr/local/Cellar/hadoop/2.8.1/libexec/etc/hadoop/core-site.xml，加入以下配置：</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.defaultFS&lt;/name&gt;
        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;</code></pre><p>进入/usr/local/Cellar/hadoop/2.8.1/libexec/etc/hadoop/hdfs-site.xml，加入以下配置：</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;</code></pre><p>进入/usr/local/Cellar/hadoop/2.8.1/libexec/etc/hadoop/hadoop-env.sh，将</p>
<pre><code>export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true&quot;</code></pre><p>修改为</p>
<pre><code>export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc=&quot;</code></pre><p>进入/usr/local/Cellar/hadoop/2.8.1/libexec/etc/hadoop/yarn-env.sh，添加</p>
<pre><code>YARN_OPTS=&quot;$YARN_OPTS -Djava.security.krb5.realm=OX.AC.UK -Djava.security.krb5.kdc=kdc0.ox.ac.uk:kdc1.ox.ac.uk&quot;</code></pre><p>进行YARN配置，配置mapred-site.xml</p>
<pre><code>cp /usr/local/Cellar/hadoop/2.8.1/libexec/etc/hadoop/mapred-site.xml.template /usr/local/Cellar/hadoop/2.8.1/libexec/etc/hadoop/mapred-site.xml</code></pre><p>打开mapred-site.xml，加入以下配置：</p>
<pre><code>&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
    &lt;value&gt;yarn&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;mapred.child.java.opts&lt;/name&gt;
    &lt;value&gt;-Xmx4096m&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;</code></pre><p>打开/usr/local/Cellar/hadoop/2.8.1/libexec/etc/hadoop/yarn-site.xml，加入以下配置：</p>
<pre><code>&lt;property&gt;
     &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
     &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
&lt;/property&gt;</code></pre><p>格式化HDFS</p>
<pre><code>$ rm -rf /tmp/hadoop-yourusername
$ hadoop namenode -format</code></pre><h3 id="启动HDFS和MapReduce"><a href="#启动HDFS和MapReduce" class="headerlink" title="启动HDFS和MapReduce"></a>启动HDFS和MapReduce</h3><p>启动HDFS</p>
<pre><code>$ /usr/local/Cellar/hadoop/2.8.1/sbin/start-dfs.sh</code></pre><p>启动MapReduce</p>
<pre><code>$ /usr/local/Cellar/hadoop/2.8.1/sbin/start-yarn.sh</code></pre><p>检查启动情况</p>
<pre><code>$ jps</code></pre><p>正常启动应该会有以下5个java进程。</p>
<pre><code>NameNode
SecondaryNameNode
DataNode
NodeManager
ResourceManager</code></pre><h3 id="可视化查看"><a href="#可视化查看" class="headerlink" title="可视化查看"></a>可视化查看</h3><p>Cluster Status <a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088</a><br>HDFS status <a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070</a><br>secondaryNamenode <a href="http://localhost:50090/" target="_blank" rel="noopener">http://localhost:50090</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By MrHup</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>