<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MrHup.code</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MrHup.code">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="MrHup.code">
<meta property="og:locale" content="cn">
<meta property="article:author" content="MrHup">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MrHup.code" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MrHup.code</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">HeapAndStack</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-KVO简析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/18/KVO%E7%AE%80%E6%9E%90/" class="article-date">
  <time datetime="2018-04-18T13:31:57.000Z" itemprop="datePublished">2018-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/18/KVO%E7%AE%80%E6%9E%90/">KVO简析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVO是一种键值观察机制，是Cocoa Binding的基础。通过它，一个对象能在当另一个对象的属性被修改时得到通知。现在让我们来探究一下这个神奇的KVO。</p>
<h2 id="KVO的实现机制"><a href="#KVO的实现机制" class="headerlink" title="KVO的实现机制"></a>KVO的实现机制</h2><p>KVO是通过runtime来实现的。当首次观察一个对象时，KVO会在runtime时创建一个新的继承原先类的子类。在这个新的子类中，它重写了所有被观察键的set方法。同时它转换了这个对象的<code>isa</code>指针，是它成为这个新子类的实例。最后通过这个重写的set方法，通知观察者值的改变。<br>但是苹果不想把这个实现机制暴露出来，它企图通过重写<code>-class</code>方法，欺骗我们这个类没有改变，就是原先的类。其实通过深挖，可以发现其中的奥妙。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">-----------TestClass.h--------------</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface TestClass : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger x;</span><br><span class="line">@property (nonatomic, assign) NSInteger y;</span><br><span class="line">@property (nonatomic, assign) NSInteger z;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------TestClass.m--------------</span><br><span class="line">#import &quot;TestClass.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation TestClass</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">-----------main.m--------------</span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &quot;TestClass.h&quot;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static NSArray *ClassMethodNames(Class c) &#123;</span><br><span class="line">    NSMutableArray *array &#x3D; [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    unsigned int methodCount &#x3D; 0;</span><br><span class="line">    Method *methodList &#x3D; class_copyMethodList(c, &amp;methodCount);</span><br><span class="line">    unsigned int i;</span><br><span class="line">    for (int i&#x3D;0; i&lt;methodCount; i++) &#123;</span><br><span class="line">        [array addObject:NSStringFromSelector(method_getName(methodList[i]))];</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void PrintDescription(NSString *name, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    NSString *str &#x3D; [NSString stringWithFormat:</span><br><span class="line">                     @&quot;%@: %@\n\tNSObject class %s\n\tRuntime class %s\n\timplements methods &lt;%@&gt;\n\n&quot;,</span><br><span class="line">                     name,</span><br><span class="line">                     obj,</span><br><span class="line">                     class_getName([obj class]),</span><br><span class="line">                     class_getName(object_getClass(obj)),</span><br><span class="line">                     [ClassMethodNames(object_getClass(obj)) componentsJoinedByString:@&quot;, &quot;]];</span><br><span class="line">    printf(&quot;%s\n&quot;, [str UTF8String]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        TestClass *x &#x3D; [[TestClass alloc] init];</span><br><span class="line">        TestClass *y &#x3D; [[TestClass alloc] init];</span><br><span class="line">        TestClass *xy &#x3D; [[TestClass alloc] init];</span><br><span class="line">        TestClass *control &#x3D; [[TestClass alloc] init];</span><br><span class="line">        </span><br><span class="line">        [x addObserver:x forKeyPath:@&quot;x&quot; options:0 context:NULL];</span><br><span class="line">        [xy addObserver:x forKeyPath:@&quot;x&quot; options:0 context:NULL];</span><br><span class="line">        [y addObserver:x forKeyPath:@&quot;y&quot; options:0 context:NULL];</span><br><span class="line">        [xy addObserver:x forKeyPath:@&quot;y&quot; options:0 context:NULL];</span><br><span class="line">        </span><br><span class="line">        PrintDescription(@&quot;control&quot;, control);</span><br><span class="line">        PrintDescription(@&quot;x&quot;, x);</span><br><span class="line">        PrintDescription(@&quot;y&quot;, y);</span><br><span class="line">        PrintDescription(@&quot;xy&quot;, xy);</span><br><span class="line">        </span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这边创建了一个测试类，里面有3个属性。然后我们在main函数中创建了几个对象用来对比，来看一下在添加了KVO之后，其发生的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">control: &lt;TestClass: 0x60800003cde0&gt;</span><br><span class="line">	NSObject class TestClass</span><br><span class="line">	Runtime class TestClass</span><br><span class="line">	implements methods &lt;z, x, y, setX:, setY:, setZ:&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x: &lt;TestClass: 0x60800003cd60&gt;</span><br><span class="line">	NSObject class TestClass</span><br><span class="line">	Runtime class NSKVONotifying_TestClass</span><br><span class="line">	implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y: &lt;TestClass: 0x60800003cda0&gt;</span><br><span class="line">	NSObject class TestClass</span><br><span class="line">	Runtime class NSKVONotifying_TestClass</span><br><span class="line">	implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xy: &lt;TestClass: 0x60800003cdc0&gt;</span><br><span class="line">	NSObject class TestClass</span><br><span class="line">	Runtime class NSKVONotifying_TestClass</span><br><span class="line">	implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;</span><br></pre></td></tr></table></figure>

<p>我们看到在添加了KVO之后，其<code>NSObject class</code>和<code>Runtime class</code>出现了差异。同时Runtime中新实现的类的方法都实现了<code>class</code>,<code>dealloc</code>和<code>_isKVOA</code>方法。另外，被观察的键值的set方法也被重写了。</p>
<h2 id="KVO的缺点"><a href="#KVO的缺点" class="headerlink" title="KVO的缺点"></a>KVO的缺点</h2><p>KVO虽然是一种很强大的功能，但是在使用上，确有很多缺点。</p>
<ol>
<li><code>-addObserver:forKeyPath:options:context:</code>方法不能传一个通用的selector来执行回调触发。<br> 在NSNotificationCenter中，你可以传入一个selector来执行回调触发。这可以很好的区分当前类和父类的回调执行。但是当使用KVO时，你必须重写<code>-observeValueForKeyPath:ofObject:change:context:</code>方法，同时得决定是在当前类中处理回调还是传给父类来处理回调。</li>
<li>context参数用处不大。<br> 由于上面的缺陷，所以要引入context参数来区分是子类还是父类。</li>
<li><code>-removeObserver:forKeyPath:</code>没有足够的参数<br> 这个方法没有context参数。这样如果父类和子类注册同一个key，那么在取消观察时会把两个都取消掉。</li>
</ol>
<h2 id="优化KVO"><a href="#优化KVO" class="headerlink" title="优化KVO"></a>优化KVO</h2><p>虽然KVO很强大，但是使用起来确有很多不便。因此我们可以自己封装一下KVO，同时用BLOCK来返回回调。或者可以按照苹果的思路，自己实现一个KVO。</p>
<h3 id="封装KVO"><a href="#封装KVO" class="headerlink" title="封装KVO"></a>封装KVO</h3><p>封装KVO的实现具体可以参考YYKit中的<code>NSObject+YYAddForKVO</code>。其实现原理是内部添加一个实例对象，把观察对象改为这个实例对象。同时通过runtime添加一个数组，用来维护这些实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserverBlockForKeyPath:(NSString *)keyPath block:(void (^)(__weak id obj, id oldVal, id newVal))block &#123;</span><br><span class="line">    if (!keyPath || !block) return;</span><br><span class="line">    _YYNSObjectKVOBlockTarget *target &#x3D; [[_YYNSObjectKVOBlockTarget alloc] initWithBlock:block];</span><br><span class="line">    NSMutableDictionary *dic &#x3D; [self _yy_allNSObjectObserverBlocks];</span><br><span class="line">    NSMutableArray *arr &#x3D; dic[keyPath];</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        arr &#x3D; [NSMutableArray new];</span><br><span class="line">        dic[keyPath] &#x3D; arr;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr addObject:target];</span><br><span class="line">    [self addObserver:target forKeyPath:keyPath options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableDictionary *)_yy_allNSObjectObserverBlocks &#123;</span><br><span class="line">    NSMutableDictionary *targets &#x3D; objc_getAssociatedObject(self, &amp;block_key);</span><br><span class="line">    if (!targets) &#123;</span><br><span class="line">        targets &#x3D; [NSMutableDictionary new];</span><br><span class="line">        objc_setAssociatedObject(self, &amp;block_key, targets, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    return targets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自己实现KVO"><a href="#自己实现KVO" class="headerlink" title="自己实现KVO"></a>自己实现KVO</h3><p>通过分析KVO的实现原理，我们大概知道如何实现一个KVO，这样我们就可以自己实现一个类似的，同时增加block返回。具体的实现可以参考<a href="https://bitbucket.org/iamleeg/observerpattern" target="_blank" rel="noopener">The ObserverPattern implementation(MRC)</a>或者<a href="https://github.com/okcomp/ImplementKVO" target="_blank" rel="noopener">ImplementKVO(ARC)</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^PGObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (KVO)</span><br><span class="line"></span><br><span class="line">- (void)PG_addObserver:(NSObject *)observer</span><br><span class="line">                forKey:(NSString *)key</span><br><span class="line">             withBlock:(PGObservingBlock)block;</span><br><span class="line"></span><br><span class="line">- (void)PG_removeObserver:(NSObject *)observer forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>首先通过category，增加了两个KVO方法。其<code>PG_addObserver:forKey:withBlock:</code>大致实现如下：</p>
<ol>
<li>检查对象的类有没有相应的 setter 方法。如果没有抛出异常；</li>
<li>检查对象 isa 指向的类是不是一个 KVO 类。如果不是，新建一个继承原来类的子类，并把 isa 指向这个新建的子类；</li>
<li>检查对象的 KVO 类重写过没有这个 setter 方法。如果没有，添加重写的 setter 方法；</li>
<li>添加这个观察者</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName</span><br><span class="line">&#123;</span><br><span class="line">    NSString *kvoClazzName &#x3D; [kPGKVOClassPrefix stringByAppendingString:originalClazzName];</span><br><span class="line">    Class clazz &#x3D; NSClassFromString(kvoClazzName);</span><br><span class="line">    </span><br><span class="line">    if (clazz) &#123;</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class doesn&#39;t exist yet, make it</span><br><span class="line">    Class originalClazz &#x3D; object_getClass(self);</span><br><span class="line">    Class kvoClazz &#x3D; objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; grab class method&#39;s signature so we can borrow it</span><br><span class="line">    Method clazzMethod &#x3D; class_getInstanceMethod(originalClazz, @selector(class));</span><br><span class="line">    const char *types &#x3D; method_getTypeEncoding(clazzMethod);</span><br><span class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</span><br><span class="line">    </span><br><span class="line">    objc_registerClassPair(kvoClazz);</span><br><span class="line">    </span><br><span class="line">    return kvoClazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你需要通过runtime建一个原先类的子类。<code>objc_allocateClassPair</code>和<code>objc_registerClassPair</code>两个方法用来创建和注册子类。同时这边也通过<code>class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types)</code>改写了class类来迷惑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void kvo_setter(id self, SEL _cmd, id newValue)</span><br><span class="line">&#123;</span><br><span class="line">    NSString *setterName &#x3D; NSStringFromSelector(_cmd);</span><br><span class="line">    NSString *getterName &#x3D; getterForSetter(setterName);</span><br><span class="line">    </span><br><span class="line">    if (!getterName) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id oldValue &#x3D; [self valueForKey:getterName];</span><br><span class="line">    </span><br><span class="line">    struct objc_super superclazz &#x3D; &#123;</span><br><span class="line">        .receiver &#x3D; self,</span><br><span class="line">        .super_class &#x3D; class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; cast our pointer so the compiler won&#39;t complain</span><br><span class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) &#x3D; (void *)objc_msgSendSuper;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; call super&#39;s setter, which is original class&#39;s setter method</span><br><span class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; look up observers and call the blocks</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kPGKVOAssociatedObservers));</span><br><span class="line">    for (PGObservationInfo *each in observers) &#123;</span><br><span class="line">        if ([each.key isEqualToString:getterName]) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                each.block(self, getterName, oldValue, newValue);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边重写了新子类的set方法，通知每个观察者。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了KVO的实现原理及其缺点，同时描述了如何改进现有的KVO和实现自己的KVO。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="noopener">Key-Value Observing</a><br><a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" target="_blank" rel="noopener">Key-Value Observing Done Right</a><br><a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="noopener">如何自己动手实现 KVO</a><br><a href="https://github.com/ibireme/YYKit" target="_blank" rel="noopener">YYKit</a><br><a href="http://www.sicpers.info/2013/12/by-your-_cmd/" target="_blank" rel="noopener">By your _cmd</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/18/KVO%E7%AE%80%E6%9E%90/" data-id="ck736a2qf000qees66bi14i6f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVO/" rel="tag">KVO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime/" rel="tag">runtime</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Swift中的函数派发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/Swift%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2018-04-12T06:57:20.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/Swift%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/">Swift中的函数派发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>函数派发机制指的是程序如何找到函数并执行操作的机制。各种各样不同的需求导致不同的函数派发机制。有时可能希望函数直接执行，比如C++的默认派发机制，有时可能需要函数在运行时执行，那就需要通过函数表派发，比如java，或者需要通过消息派发，比如Objc。但是每种派发机制都有优缺点。</p>
<h2 id="常见的函数派发"><a href="#常见的函数派发" class="headerlink" title="常见的函数派发"></a>常见的函数派发</h2><h3 id="静态派发"><a href="#静态派发" class="headerlink" title="静态派发"></a>静态派发</h3><p>静态派发也叫直接派发。在静态派发中，编译器直接找到相关指令的位置。当函数调用时，系统直接跳转到函数的内存地址执行操作。这样的好处就是执行快，同时允许编译器能够执行例如内联等优化。事实上，编译期在编译阶段为了能够获取最大的性能提升，都尽量将函数静态化。</p>
<h3 id="动态派发"><a href="#动态派发" class="headerlink" title="动态派发"></a>动态派发</h3><p>动态派发是一种运行时机制。在运行时决定函数的执行。这种机制产生的原因就是面向对象语言的多态性。原先的静态派发由于在编译时就决定了，所以灵活性就不够。</p>
<h3 id="函数表派发"><a href="#函数表派发" class="headerlink" title="函数表派发"></a>函数表派发</h3><p>函数表派发就是通过函数表来查找相应的函数地址。每个类在创建时都会创建一个函数表，用来记录函数的指针。同时子类在创建时也会创建一个函数表，如果函数是override的，则使用一个新的指针，用于区分父类中相同函数的指针。如果这个函数是父类中有且没被override的，则存储的就是原先的指针。具体可以看下面的代码和图示。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">drink</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行Bird类中的eat函数时整个流程如下：<br>1.读取Bird类的函数表地址Oxb00。<br>2.读取到eat函数，也就是0xb00+1。<br>3.跳转到0x330执行具体的操作。</p>
<p><img src="table_dispatch.png" alt="函数表"></p>
<p>从上面的分析中我们可以知道，要具体执行fly函数，就必须进行两次读取和一次跳转。同时编译器对于函数表派发的函数是无法执行优化的。这样，执行速度必然就变慢了。</p>
<h3 id="消息派发"><a href="#消息派发" class="headerlink" title="消息派发"></a>消息派发</h3><p>Objc的函数派发都是基于消息派发的。这种机制极具动态性，既可以通过swizzling修改函数的实现，也可以通过isa-swizzling修改对象。<br>还是上面那段代码，然后看一下通过消息派发执行Bird中的drink函数的步骤。<br>1.到自己的方法列表中去找，结果没找到。<br>2.去它的父类Animal中去找，发现找到了，就执行相应的逻辑。<br><img src="message_dispatch.png" alt="消息派发"><br>从中我们可以发现，如果这个方法在NSObject中，那么每次都要找好多次，就会非常慢。解决的方法就是利用方法缓存。如果调用过一次，就会放入缓存列表中，下次再调用的话，就会非常快。</p>
<h2 id="swift中的函数派发"><a href="#swift中的函数派发" class="headerlink" title="swift中的函数派发"></a>swift中的函数派发</h2><p>swift中函数派发包含了上述3种情况。总结如下表所示。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">直接派发</th>
<th align="center">函数表派发</th>
<th align="center">消息派发</th>
</tr>
</thead>
<tbody><tr>
<td align="center">强制声明</td>
<td align="center">static or final</td>
<td align="center">-</td>
<td align="center">dynamic</td>
</tr>
<tr>
<td align="center">Class</td>
<td align="center">extensions</td>
<td align="center">初始声明</td>
<td align="center">extensions with @objc</td>
</tr>
<tr>
<td align="center">Protocol</td>
<td align="center">extensions</td>
<td align="center">初始声明</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">值类型</td>
<td align="center">所有方法</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>具体的例子可以看如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Noisy</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>  <span class="comment">//函数表派发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Noisy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;  <span class="comment">//函数表派发</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isAnnoying</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>&#125;  <span class="comment">//直接派发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">Noisy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125; <span class="comment">//函数表派发</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isAnnoying</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; <span class="comment">//函数表派发</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;&#125; <span class="comment">//函数表派发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;&#125; <span class="comment">//直接派发</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">getWild</span><span class="params">()</span></span> &#123;&#125; <span class="comment">//消息派发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getArea</span><span class="params">()</span></span> &#123; &#125; <span class="comment">//直接派发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来看，具体的派发机制还是有点绕的。但是我们在选择函数派发机制时有一个原则：<br>1.如果不需要多态，直接派发优先考虑。<br>2.如果需要覆写，函数表派发优先考虑。<br>3.如果需要覆写和对Objective-C可见，那就用消息派发。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了三种常用的函数派发机制，并介绍总结了swift中的派发机制和选择时的原则。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://trinhngocthuyen.github.io/2017-09-25-method-dispatch-in-swift.html" target="_blank" rel="noopener">Method dispatch in Swift</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/12/Swift%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/" data-id="ck736a2qp001iees6611b8lrf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/" rel="tag">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/" rel="tag">函数派发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AFNetworkReachabilityManager源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/11/AFNetworkReachabilityManager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2018-04-11T03:19:06.000Z" itemprop="datePublished">2018-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/11/AFNetworkReachabilityManager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AFNetworkReachabilityManager源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>AFNetworkReachabilityManager是AFNetworking框架中通过监控蜂窝网络和wifi网络接口的域名和地址的可达性的网络状态管理类。它其实是封装了底层SystemConfiguration类，使得网络监控变得像一个插件一样，简单易用。</p>
<h2 id="AFNetworkReachabilityManager分析"><a href="#AFNetworkReachabilityManager分析" class="headerlink" title="AFNetworkReachabilityManager分析"></a>AFNetworkReachabilityManager分析</h2><p>首先我们看一下头文件中的网络状态枚举。它里面有4种状态值，分为未知、网络不可达、蜂窝网络和Wifi。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkReachabilityStatus) &#123;</span><br><span class="line">    AFNetworkReachabilityStatusUnknown          = <span class="number">-1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusNotReachable     = <span class="number">0</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWWAN = <span class="number">1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWiFi = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们看到一个宏组合。这表示在这两个宏之间的指针都是非空的。如果需要指定可以为空，则需单独指定nullable参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>接着我们看到4个只读的属性值。其含义在代码中写的很清楚。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> The current network reachability status.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFNetworkReachabilityStatus networkReachabilityStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not the network is currently reachable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isReachable) <span class="built_in">BOOL</span> reachable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not the network is currently reachable via WWAN.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isReachableViaWWAN) <span class="built_in">BOOL</span> reachableViaWWAN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Whether or not the network is currently reachable via WiFi.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isReachableViaWiFi) <span class="built_in">BOOL</span> reachableViaWiFi;</span><br></pre></td></tr></table></figure>

<p>后面三个属性的判断实现也是非常简单的。通过比对networkReachabilityStatus的状态来判断。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isReachable &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isReachableViaWWAN] || [<span class="keyword">self</span> isReachableViaWiFi];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isReachableViaWWAN &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isReachableViaWiFi &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们看到<code>+ (instancetype)sharedManager</code>这个方法。这个方法一看就是一个单例方法。然后我们m文件中看实现。内部用了<code>dispatch_once_t</code>实现单例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AFNetworkReachabilityManager *_sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedManager = [<span class="keyword">self</span> manager];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sharedManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_once</code>中调用了<code>+ (instancetype)manager</code>方法。这里区分了新老版本，新版本socket地址使用ipv6，老版本使用ipv4。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)manager</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</span></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in6 address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin6_len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    address.sin6_family = AF_INET6;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> managerForAddress:&amp;address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>+ (instancetype)manager</code>的最后调用了<code>+ (instancetype)managerForAddress:(const void *)address</code>。<code>SCNetworkReachabilityRef</code>是里面检测网络状态最核心的句柄，它通过刚才传入的地址初始化。另外<code>SCNetworkReachabilityRef</code>由于属于底层框架，不属于NSObject，需要手动管理引用计数。此外<code>- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability</code>中设置了<code>networkReachabilityStatus</code>的初始化值为<code>AFNetworkReachabilityStatusUnknown</code>，同时把<code>reachability</code>赋给了<code>networkReachability</code>。这个<code>networkReachability</code>很关键，后面的逻辑判断都会用到它。到这里初始化就结束了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)managerForAddress:(<span class="keyword">const</span> <span class="keyword">void</span> *)address &#123;</span><br><span class="line">    <span class="built_in">SCNetworkReachabilityRef</span> reachability = <span class="built_in">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)address);</span><br><span class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(reachability);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithReachability:(<span class="built_in">SCNetworkReachabilityRef</span>)reachability &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _networkReachability = <span class="built_in">CFRetain</span>(reachability);</span><br><span class="line">    <span class="keyword">self</span>.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，它还提供了从域名初始化，与从socket address初始化类似。只是没有提供相应的单例初始化方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)managerForDomain:(<span class="built_in">NSString</span> *)domain &#123;</span><br><span class="line">    <span class="built_in">SCNetworkReachabilityRef</span> reachability = <span class="built_in">SCNetworkReachabilityCreateWithName</span>(kCFAllocatorDefault, [domain UTF8String]);</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(reachability);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完了初始化，我们来到重头戏<code>- (void)startMonitoring</code>。在这个类的说明中指出，要检测网络状态，必须先执行这个方法。然后我们来看一下其内部逻辑。<br>1.执行了停止原先监控的操作。其内部就是退出runloop操作。<br>2.检查<code>networkReachability</code>是否存在，如果不存在，直接返回。<br>3.创建了一个callback的block回调，就是为了把网络状态通过<code>networkReachabilityStatusBlock</code>回调出去。这里面为了防止循环引用，引入了weak-strong dance。<br>4.创建了<code>SCNetworkReachabilityContext</code>，引入了上一步创建的callback。<br>5.设置了<code>SCNetworkReachabilitySetCallback</code>。当网络状态改变时会进入<code>AFNetworkReachabilityCallback</code>。<br>6.通过<code>SCNetworkReachabilityScheduleWithRunLoop</code>把这个检测任务丢入主runloop。<br>7.发起了一个异步优先级低的线程获取当前网络状态，并回调给callback。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">SCNetworkReachabilitySetCallback</span>(<span class="keyword">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    <span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>),^&#123;</span><br><span class="line">        <span class="built_in">SCNetworkReachabilityFlags</span> flags;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SCNetworkReachabilityGetFlags</span>(<span class="keyword">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下上面第5步用到的<code>AFNetworkReachabilityCallback</code>方法，这个一个静态方法，其中有三个参数target、flags和info。其中target和info就是<code>SCNetworkReachabilitySetCallback</code>中传入的<code>self.networkReachability</code>和<code>&amp;context</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFNetworkReachabilityCallback(<span class="built_in">SCNetworkReachabilityRef</span> __unused target, <span class="built_in">SCNetworkReachabilityFlags</span> flags, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看到<code>AFNetworkReachabilityCallback</code>内部调用了另一个静态方法<code>AFPostReachabilityStatusChange</code>。这里通过<code>AFNetworkReachabilityStatusForFlags</code>方法来判断flags对应的网络状态。然后把状态通过block回调出去。同时还发了一个change的通知。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFPostReachabilityStatusChange(<span class="built_in">SCNetworkReachabilityFlags</span> flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">            block(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSNotificationCenter</span> *notificationCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:<span class="literal">nil</span> userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AFNetworkReachabilityStatusForFlags</code>方法来判断状态其实很简单。SCNetworkReachabilityFlags是一个枚举值，通过综合判断flags的状态，就可以得出网络是否可达，是wifi网络还是蜂窝网络的判断。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(uint32_t, <span class="built_in">SCNetworkReachabilityFlags</span>) &#123;</span><br><span class="line">	kSCNetworkReachabilityFlagsTransientConnection	= <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</span><br><span class="line">	kSCNetworkReachabilityFlagsReachable		= <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionRequired	= <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionOnTraffic	= <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</span><br><span class="line">	kSCNetworkReachabilityFlagsInterventionRequired	= <span class="number">1</span>&lt;&lt;<span class="number">4</span>,</span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionOnDemand	= <span class="number">1</span>&lt;&lt;<span class="number">5</span>,	<span class="comment">// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_0)</span></span><br><span class="line">	kSCNetworkReachabilityFlagsIsLocalAddress	= <span class="number">1</span>&lt;&lt;<span class="number">16</span>,</span><br><span class="line">	kSCNetworkReachabilityFlagsIsDirect		= <span class="number">1</span>&lt;&lt;<span class="number">17</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	TARGET_OS_IPHONE</span></span><br><span class="line">	kSCNetworkReachabilityFlagsIsWWAN		= <span class="number">1</span>&lt;&lt;<span class="number">18</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">// TARGET_OS_IPHONE</span></span></span><br><span class="line"></span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionAutomatic	= kSCNetworkReachabilityFlagsConnectionOnTraffic</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(<span class="built_in">SCNetworkReachabilityFlags</span> flags) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != <span class="number">0</span>) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">BOOL</span> canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;</span><br><span class="line">    <span class="keyword">if</span> (isNetworkReachable == <span class="literal">NO</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusNotReachable;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	TARGET_OS_IPHONE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class="number">0</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样整个<code>- (void)startMonitoring</code>就结束了。然后我们来看一下<code>- (void)stopMonitoring</code>停止监控的方法。<br>1.判断<code>networkReachability</code>是否为空，如果为空，则直接返回。<br>2.通过<code>SCNetworkReachabilityUnscheduleFromRunLoop</code>退出主runloop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)stopMonitoring &#123;</span><br><span class="line">    if (!self.networkReachability) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，整个AFNetworkReachabilityManager类的分析就结束了。我们可以看到，它通过优雅的封装，使得网络状态的判断变得十分方便。另外私有函数都是通过静态函数的方法呈现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a><br><a href="https://github.com/Draveness/analyze/blob/master/contents/AFNetworking/AFNetworkReachabilityManager%20%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%88%E5%9B%9B%EF%BC%89.md" target="_blank" rel="noopener">AFNetworkReachabilityManager 监控网络状态（四）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/11/AFNetworkReachabilityManager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ck736a2pm0000ees6b3bi3may" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-隐藏在图片中的密钥" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/09/%E9%9A%90%E8%97%8F%E5%9C%A8%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E5%AF%86%E9%92%A5/" class="article-date">
  <time datetime="2018-04-09T02:03:23.000Z" itemprop="datePublished">2018-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%89%E5%85%A8/">安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/09/%E9%9A%90%E8%97%8F%E5%9C%A8%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E5%AF%86%E9%92%A5/">隐藏在图片中的密钥</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在客户端开发的时候，有时需要把密钥保存在本地。这时就会遇到密钥安全性的问题。要保证密钥安全性，无非就是混淆、隐藏、白盒等手段。本文以隐藏在图片中来阐述密钥的安全保存。</p>
<h2 id="PNG图片"><a href="#PNG图片" class="headerlink" title="PNG图片"></a>PNG图片</h2><p>便携式网络图形(PNG)是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性。</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>PNG图像格式文件由一个8字节的PNG文件标识域和3个以上的后续数据块(IHDR, IDAT, IEND)组成。</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>89</td>
<td>用于检测传输系统是否支持8位的字符编码</td>
</tr>
<tr>
<td>50 4E 47</td>
<td>PNG每个字母对应的ASCII</td>
</tr>
<tr>
<td>0D 0A</td>
<td>DOS风格的换行符</td>
</tr>
<tr>
<td>1A</td>
<td>在DOS命令下，用于阻止文件显示的文件结束符</td>
</tr>
<tr>
<td>0A</td>
<td>Unix风格的换行符</td>
</tr>
<tr>
<td>PNG定义了两种类型的数据块：一种是PNG文件必须包含、读写软件也都必须要支持的关键块(critical chunk); 另一种叫做辅助块, PNG允许软件忽略它不认识的附加块。</td>
<td></td>
</tr>
<tr>
<td>关键数据块中的4个标准数据块:</td>
<td></td>
</tr>
<tr>
<td>- 文件头数据块IHDR：包含有图像基本信息，作为第一个数据块出现并只出现一次。</td>
<td></td>
</tr>
<tr>
<td>- 调色板数据块PLET：必须放在图像数据块之前。</td>
<td></td>
</tr>
<tr>
<td>- 图像数据块IDAT：存储实际图像数据。PNG数据允许包含多个连续的图像数据块。</td>
<td></td>
</tr>
<tr>
<td>- 图像结束数据IEND：放在文件尾部，表示PNG数据流结束。</td>
<td></td>
</tr>
<tr>
<td>每个数据块都由下表所示的4个域组成</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>字节数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>4字节</td>
<td>指定数据块中数据域的长度，不超过2^31-1字节</td>
</tr>
<tr>
<td>Chunk Type Code(数据块类型)</td>
<td>4字节</td>
<td>数据块类型码由ASCII字母A-Za-z组成</td>
</tr>
<tr>
<td>Chunk Data(数据块数据)</td>
<td>可变长度</td>
<td>存储按照Chunk Type Code指定的数据</td>
</tr>
<tr>
<td>CRC(循环冗余检测)</td>
<td>4字节</td>
<td>存储用来检测是否有错误的循环冗余码,计算不包括length字段</td>
</tr>
</tbody></table>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下面这张图片为例，使用Hxd工具来看一下实际的数据。</p>
<p><img src="test.png" alt="test"></p>
<p>我们用Hxd工具打开图片，首先看到的是89 50 4E 47 0D 0A 1A 0A，表示是一张PNG图片。</p>
<p><img src="hxd0.png" alt="PNG标识域"></p>
<p>紧接着的是IHDR。前面4字节表示长度，长度后面的4个字节是数据块类型，接着是数据块数据，最后4字节是CRC。</p>
<p><img src="hxd1.png" alt="IHDR"></p>
<p>再接着是PLTE调色板数据块，格式同上。</p>
<p><img src="hxd3.png" alt="PLTE"></p>
<p>然后我们会看到tEXt数据块，这个是可选数据块，里面可以放入图片的介绍说明，同时我们也可以将密钥放在其中。</p>
<p><img src="hxd5.png" alt="tEXt"></p>
<p>然后是图像数据块IDAT。</p>
<p><img src="hxd6.png" alt="IDAT"></p>
<p>最后是图像结束数据IEND。</p>
<p><img src="hxd7.png" alt="IEND"></p>
<h2 id="CRC算法"><a href="#CRC算法" class="headerlink" title="CRC算法"></a>CRC算法</h2><p>CRC是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。它是校验和的一种，是两个字节数据流采用二进制除法（没有进位，使用XOR来代替减法）相除所得到的余数。<br>PNG图片中的CRC算法为CRC32。其多项式表示为0x04C11DB7或者0xEDB88320(反转)。另外CRC计算值可以到在线网站比如<a href="http://www.ip33.com/crc.html" target="_blank" rel="noopener">ip33</a>上计算得到。</p>
<p>下面是用代码实现的CRC32算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getCrc32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* inStr, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> CRC32Table[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> CRC;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        CRC = i;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CRC &amp; <span class="number">1</span>)</span><br><span class="line">                CRC = (CRC &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88320</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                CRC &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CRC32Table[i] = CRC;</span><br><span class="line">    &#125;</span><br><span class="line">    CRC = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> m = <span class="number">0</span>; m &lt; len; m++) &#123;</span><br><span class="line">        CRC = (CRC &gt;&gt; <span class="number">8</span>) ^ CRC32Table[(CRC &amp; <span class="number">0xFF</span>) ^ inStr[m]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CRC ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">return</span> CRC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片中的密钥"><a href="#图片中的密钥" class="headerlink" title="图片中的密钥"></a>图片中的密钥</h2><h3 id="tEXt隐藏"><a href="#tEXt隐藏" class="headerlink" title="tEXt隐藏"></a>tEXt隐藏</h3><p>在图片中增加密钥，可以在非关键字段比如tEXt中进行。首先要去除原先图片中tEXt字段，然后填充自己要加入的tEXt字段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">generateNewPng</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp, *fpnew;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkCRC32 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> crc32 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> Signature[<span class="number">8</span>] = &#123;<span class="number">0x89</span>,<span class="number">0x50</span>,<span class="number">0x4e</span>,<span class="number">0x47</span>,<span class="number">0x0d</span>,<span class="number">0x0a</span>,<span class="number">0x1a</span>,<span class="number">0x0a</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> IEND[<span class="number">12</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x49</span>,<span class="number">0x45</span>,<span class="number">0x4e</span>,<span class="number">0x44</span>,<span class="number">0xae</span>,<span class="number">0x42</span>,<span class="number">0x60</span>,<span class="number">0x82</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"oldpng.png"</span>, <span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fpnew = fopen(<span class="string">"newpng.png"</span>, <span class="string">"wb"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);     <span class="comment">//移动末尾</span></span><br><span class="line">    len = (<span class="keyword">int</span>)ftell(fp);       <span class="comment">//计算长度</span></span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[len];</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);     <span class="comment">//移动首</span></span><br><span class="line">    fread(buf, len, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total len = %d\n"</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------------------------------------\n"</span>);</span><br><span class="line">    fseek(fp, <span class="number">8</span>, SEEK_SET);</span><br><span class="line">    ChunkOffset = <span class="number">8</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    fwrite(Signature, <span class="number">8</span>, <span class="number">1</span>, fpnew);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, len);    <span class="comment">//重置 0</span></span><br><span class="line">        fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp);   <span class="comment">//读完文件流位置指针后移size * count。读的是长度</span></span><br><span class="line">        fwrite(buf, <span class="number">4</span>, <span class="number">1</span>, fpnew);   <span class="comment">//写入新png</span></span><br><span class="line">        ChunkLen = (buf[<span class="number">0</span>]&lt;&lt;<span class="number">24</span>)|(buf[<span class="number">1</span>]&lt;&lt;<span class="number">16</span>)|(buf[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">3</span>];</span><br><span class="line">        fread(buf,<span class="number">4</span>+ChunkLen,<span class="number">1</span>,fp);     <span class="comment">//读的是数据块类型和内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+]ChunkName:%c%c%c%c        "</span>,buf[<span class="number">0</span>],buf[<span class="number">1</span>],buf[<span class="number">2</span>],buf[<span class="number">3</span>]); <span class="comment">//数据</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>((<span class="keyword">char</span> *)buf, <span class="string">"tEXt"</span>, <span class="number">4</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//过滤掉辅助数据块</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Ancillary Chunk\n"</span>);</span><br><span class="line">            fseek(fpnew, <span class="number">-4</span>, SEEK_CUR);</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Palette Chunk\n"</span>);</span><br><span class="line">            fwrite(buf, <span class="number">4</span>+ChunkLen, <span class="number">1</span>, fpnew);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   ChunkOffset:0x%08x    \n"</span>,ChunkOffset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   ChunkLen: %10d        \n"</span>,ChunkLen);</span><br><span class="line">        ChunkOffset+=ChunkLen+<span class="number">12</span>;</span><br><span class="line">        crc32=getCrc32(buf,ChunkLen+<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   ExpectCRC32:%08X\n"</span>,crc32);</span><br><span class="line">        fread(buf,<span class="number">4</span>,<span class="number">1</span>,fp);      </span><br><span class="line">        ChunkCRC32=(buf[<span class="number">0</span>]&lt;&lt;<span class="number">24</span>)|(buf[<span class="number">1</span>]&lt;&lt;<span class="number">16</span>)|(buf[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   ChunkCRC32: %08X        "</span>,ChunkCRC32);  </span><br><span class="line">        <span class="keyword">if</span>(crc32!=ChunkCRC32)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[!]CRC32Check Error!\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Check Success!\n\n"</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    fwrite(buf, <span class="number">4</span>, <span class="number">1</span>, fpnew);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ChunkLen=(<span class="keyword">int</span>)ftell(fp);   <span class="comment">//得到当前文件的偏移位置</span></span><br><span class="line">        <span class="keyword">if</span>(ChunkLen==(len<span class="number">-12</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n----------------------------------------------------\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Total Chunk:%d\n"</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> payload[] = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *tmpbuf;</span><br><span class="line">    <span class="keyword">int</span> templen;</span><br><span class="line">    <span class="comment">//    int crc32;</span></span><br><span class="line">    templen = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(payload);</span><br><span class="line">    tmpbuf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[templen+<span class="number">12</span>];</span><br><span class="line">    tmpbuf[<span class="number">0</span>] = templen&gt;&gt;<span class="number">24</span>&amp;<span class="number">0xff</span>;</span><br><span class="line">    tmpbuf[<span class="number">1</span>] = templen&gt;&gt;<span class="number">16</span>&amp;<span class="number">0xff</span>;</span><br><span class="line">    tmpbuf[<span class="number">2</span>] = templen&gt;&gt;<span class="number">8</span>&amp;<span class="number">0xff</span>;</span><br><span class="line">    tmpbuf[<span class="number">3</span>] = templen&amp;<span class="number">0xff</span>;</span><br><span class="line">    tmpbuf[<span class="number">4</span>] = <span class="string">'t'</span>;</span><br><span class="line">    tmpbuf[<span class="number">5</span>] = <span class="string">'E'</span>;</span><br><span class="line">    tmpbuf[<span class="number">6</span>] = <span class="string">'X'</span>;</span><br><span class="line">    tmpbuf[<span class="number">7</span>] = <span class="string">'t'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++) &#123;</span><br><span class="line">        buf[j+<span class="number">8</span>] = payload[j];</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len+<span class="number">8</span>] = <span class="number">0X88</span>;</span><br><span class="line">    buf[len+<span class="number">9</span>] = <span class="number">0X1E</span>;</span><br><span class="line">    buf[len+<span class="number">10</span>] = <span class="number">0XE2</span>;</span><br><span class="line">    buf[len+<span class="number">11</span>] = <span class="number">0X27</span>;</span><br><span class="line">    fwrite(buf, len+<span class="number">12</span>, <span class="number">1</span>, fp);</span><br><span class="line">    </span><br><span class="line">    fwrite(IEND, <span class="number">12</span>, <span class="number">1</span>, fpnew);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fpnew);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充完所要的数据后，接着在程序中可以解析新图片中tEXt字段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPayload</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *res)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"newpng.png"</span>, <span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);     <span class="comment">//移动末尾</span></span><br><span class="line">    len = (<span class="keyword">int</span>)ftell(fp);       <span class="comment">//计算长度</span></span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[len];</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);     <span class="comment">//移动首</span></span><br><span class="line">    fread(buf, len, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total len = %d\n"</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------------------------------------\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02X "</span>,buf[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">16</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">text</span> = <span class="string">"tEXt"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s</span><span class="params">((<span class="keyword">const</span> <span class="keyword">char</span> *)buf,len)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> start = s.<span class="built_in">find</span>(<span class="built_in">text</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *iend = <span class="string">"IEND"</span>;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">end</span> = s.<span class="built_in">find</span>(iend);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = s.substr(start+<span class="number">4</span>, <span class="built_in">end</span>-start<span class="number">-12</span>);</span><br><span class="line">    res = result.c_str();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------------------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,result.c_str());</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LBS隐藏"><a href="#LBS隐藏" class="headerlink" title="LBS隐藏"></a>LBS隐藏</h3><p>LBS隐藏是一种更加隐秘的隐藏手段。它通过改写IDAT数据中的RGB三通道数据的低3位，把密钥藏进去。因为只改写了低位数据，所以人眼往往很难区分出来。具体的实现可以参考<a href="https://github.com/livz/cloacked-pixel" target="_blank" rel="noopener">cloacked-pixel</a>。由于每个像素点最多隐藏3位，就会导致一个量的问题。当隐藏的数据比较多时，就会需要比较大的图片。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/PNG" target="_blank" rel="noopener">PNG</a><br><a href="https://zh.wikipedia.org/wiki/CRC" target="_blank" rel="noopener">CRC</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8PNG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8FPayload/" target="_blank" rel="noopener">隐写技巧——利用PNG文件格式隐藏Payload</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/09/%E9%9A%90%E8%97%8F%E5%9C%A8%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E5%AF%86%E9%92%A5/" data-id="ck736a2r8002yees64c6ya141" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E9%92%A5/" rel="tag">密钥</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-categories/index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/08/categories/index/" class="article-date">
  <time datetime="2018-04-08T11:37:00.000Z" itemprop="datePublished">2018-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/08/categories/index/">categories</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/08/categories/index/" data-id="ck736a2te004gees6hkb6hw4g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift和Objective-C的十个不同点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/08/Swift%E5%92%8CObjective-C%E7%9A%84%E5%8D%81%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%82%B9/" class="article-date">
  <time datetime="2018-04-08T01:14:14.000Z" itemprop="datePublished">2018-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/08/Swift%E5%92%8CObjective-C%E7%9A%84%E5%8D%81%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%82%B9/">Swift和Objective-C的十个不同点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2014年6月2号，苹果发布了一个新的面向对象的语言：Swift，做为Objective-C的替代者。作为一门新的语言，Swift在简单易用上面获得了大量的好评，从而它的上升速度是非常快的。<br><img src="tiobe.png" alt="2018年4月TIOBE排名"><br>从图中可以看到，Swift的排名已经超越了Objective-C。虽然在中国可能还大部分在使用Objective-C开发，但是逐渐转换为Swift是一个不可逆的趋势。</p>
<p>接下去我们将从以下10个方面展示Swift和Objective-C的不同。</p>
<ul>
<li>可选(Optionals)</li>
<li>控制流</li>
<li>类型推断</li>
<li>元组</li>
<li>字符串操作</li>
<li>Guard&amp;Defer</li>
<li>函数式编程</li>
<li>枚举</li>
<li>函数</li>
<li>Do关键字</li>
</ul>
<h3 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h3><p>可选的概念在C或者Objective-C中是不存在的。它意味着这个返回值可能有或可能为nil。我们知道，在Objective-C中，一个方法可能返回一个对象或可能返回nil。但是对于基本类型int、float等，则是没有可选的返回的。但是对于Swift而言，则是</p>
<pre><code>let a = &quot;48&quot;
let b = Int(a)
print(b!)

//output
Optional(48)</code></pre><p>Int函数这边返回一个可选类型，里面包含一个48的值。但是如果原先的字符串不是数字呢？</p>
<pre><code>let aa = &quot;error&quot;
let bb = Int(aa)
print(bb)

//output
nil</code></pre><p>从这边我们可以看到，它返回了一个nil。因为Int函数无法将非数字的字符串转换为Int。<br>我们知道对于Objective-C，如果你对nil发送消息，那将什么都不会发生。但是对于Swift，编译器则会直接报错。</p>
<pre><code>var x = Int(&quot;188&quot;)
print(x+1)

//output
error</code></pre><p>如果要使用的话，就必须强制解包，可以用以下两种方式：</p>
<pre><code>var x = Int(&quot;188&quot;)
print(x!+1)  //1.强制解包
if var y = x {  //2.optional绑定
  y += 811
  print(y)
}</code></pre><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>对于C语言或者Objective-C，你可能对({})非常熟悉。if语句或者for语句都会用到。或者可以简写去掉({})。但是对于Swift，你必须使用{}，但是()可以去掉。</p>
<pre><code>let xx = 4
if xx &lt; 5 {
  print(xx)
}</code></pre><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Swift引入了类型安全机制。一旦一个变量被申明为一个类型，那么就不能再改变了。同时编译器能够根据赋的值推断出相应的类型。</p>
<pre><code>var str = &quot;Some string&quot;
// OR
var str2:String
str2 = &quot;Other string&quot;</code></pre><p>而对于Objective-C，你必须显式的申明一个变量：</p>
<pre><code>NSString str = @&quot;There is no type inference in Objective-C :(&quot;</code></pre><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>Swift支持元组类型，它存储一组值。跟数组不同，元组中的类型不必相同的。比如：</p>
<pre><code>var t:(String, Int) = (&quot;John&quot;, 33)
print(t.0, t.1)

var j:(name:String, Int) = (&quot;Morgan&quot;, 52)
print(j.name, j.1)</code></pre><p>元组使用最多的是在函数的返回中：</p>
<pre><code>var arr = [23, 5, 7, 33, 9]

func findPosition(el:Int, arr:[Int]) -&gt; (found:Bool, position:Int)? {
  if arr.isEmpty {
    return nil
  }

  for (i, value) in arr.enumerated() {
    if value == el {
      return (true, i)
    }
  }

return (false, -1)
}

if let (isFound, elPosition) = findPosition(el: 5, arr: arr) {
  print(isFound, elPosition)
  // true 1
}</code></pre><p>在Objective-C中，可以用BLOCK来实现相似的效果，但是跟元组相比，显然麻烦多了。</p>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>Swift在字符串操作上面相比Objective-C有巨大的提高。你不必为可变和非可变字符串困扰，对于不可变的，就使用let，对于可变的是，就使用var.<br>在Swift中，字符串聚合是非常方便的：</p>
<pre><code>// Swift:
var str = &quot;My string&quot;
str += &quot; and another string”</code></pre><p>而在Objective-C中，则是非常麻烦的。</p>
<pre><code>// Obj-C:
NSString *myString = @&quot;My string&quot;;
myString = [NSString stringWithFormat:@&quot;%@ and another string&quot;, myString];</code></pre><p>同时在Objective-C你需要使用占位符来表示不同类型的数据。但是在swift则完全不需要，直接用()包含就行。</p>
<pre><code>var str = &quot;String: \(myString) | Signed 32-bit integer: \(myInt) | 64-bit floating-point number: \(myFloat)&quot;</code></pre><h3 id="Guard-amp-Defer"><a href="#Guard-amp-Defer" class="headerlink" title="Guard&amp;Defer"></a>Guard&amp;Defer</h3><p>在Objective-C中，当你逻辑复杂，需要层层判断时，往往会出现以下代码：</p>
<pre><code>enum TriangleAreaCalcError: Error {
    case AngleNotSpecified
    case InvalidAngle
    case SideANotSpecified
    case SideBNotSpecified
}

func calcTriangleArea(a: Double? , b : Double? , alpha : Double? ) throws -&gt; Double {
    if let a = a {
        if let b = b {
            if let alpha = alpha {
                if alpha &lt; 180 &amp;&amp; alpha &gt;= 0 {
                    if alpha == 180 {
                        return 0
                    }
                    return 0.5 * a * b * sin(alpha * Double.pi / 180.0)
                } else {
                    throw TriangleAreaCalcError.InvalidAngle
                }
            } else {
                throw TriangleAreaCalcError.AngleNotSpecified
            }
        } else {
            throw TriangleAreaCalcError.SideBNotSpecified
        }
    } else {
        throw TriangleAreaCalcError.SideANotSpecified
    }
}</code></pre><p>这看上去就像一个金字塔，可读性非常差。而在Swift中，你可以使用guard关键字。它表示如果条件不满足，则进入逻辑。</p>
<pre><code>func calcTriangleArea(a: Double? , b : Double? , alpha : Double? ) throws -&gt; Double {

    guard
    let a = a
    else {
        throw TriangleAreaCalcError.SideANotSpecified
    }

    guard
    let b = b
    else {
        throw TriangleAreaCalcError.SideBNotSpecified
    }

    guard
    let alpha = alpha
    else {
        throw TriangleAreaCalcError.AngleNotSpecified
    }

    if alpha == 180 {
        return Double(0)
    }

    guard alpha &lt; 180 &amp;&amp; alpha &gt;= 0
    else {
        throw TriangleAreaCalcError.InvalidAngle
    }

    return 0.5 * a * b * sin(alpha * Double.pi / 180.0)
}</code></pre><p>Swift同时提供了defer关键字，用于在退出当前范围之前执行的操作逻辑。</p>
<pre><code>func someImageFunc() -&gt; UIImage? {

    let dataSize: Int = 64
    let destData = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: dataSize)

    // ...

    guard error1
    else {
      destData.dealloc(dataSize) // #1
      return nil
    }

    guard error2
    else {
      destData.dealloc(dataSize) // #2
      return nil
    }

    guard error3
    else {
      destData.dealloc(dataSize) // #3
      return nil
    }

    destData.dealloc(dataSize) // #4
    // ...
  }</code></pre><p>从中我们可以看到，执行了4次dealloc函数来保证在退出函数之前指针被释放。但是有了defer之后，我们只要写一次就可以了</p>
<pre><code>func someImageFunc() -&gt; UIImage? {

    let dataSize: Int = 64
        let destData = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: dataSize)

    // ...

    defer {
        destData.dealloc(dataSize)
    }

    guard error
    else {
        return nil
    }

    guard error2
    else {
        return nil
    }

    guard error3
    else {
        return nil
    }

    // ...
}</code></pre><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>Swift引入了大量函数式编程特征，比如map和filter，它可以在任何实现了CollectionType协议的集合上使用。</p>
<pre><code>let a = [4, 8, 16]
print(a.map{$0 / 2})
// [2, 4, 8]

let b:[(name:String, area:String)] = [(&quot;John&quot;, &quot;iOS&quot;), (&quot;Sam&quot;, &quot;Android&quot;), (&quot;Paul&quot;, &quot;Web&quot;)]

let c = b.map({&quot;Developer \($0.name) (\($0.area))&quot;})
// [&quot;Developer John (iOS)&quot;, &quot;Developer Sam (Android)&quot;, &quot;Developer Paul (Web)”]

let d = [23, 5, 7, 12, 10]
let e = d.filter{$0 &gt; 10}
print(e) // [23, 12]

let sum = (20...30)
  .filter { $0 % 2 != 0 }
  .map { $0 * 2 }
  .reduce(0) { $0 + $1 }

print(sum) // 250</code></pre><p>而Objective-C原生是不支持这些函数式编程特征的，除非使用第三方库。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在Swift中，枚举是非常强大的。它可以包含方法，可以传参等。以下列举了一些用法：</p>
<pre><code>enum Location {
  case Address(city: String, street: String)
  case Coordinates(lat: Float, lon: Float)

  func printOut() {
    switch self {
    case let.Address(city, street):
        print(&quot;Address: &quot; + street + &quot;, &quot; + city)
    case let.Coordinates(lat, lon):
        print(&quot;Coordiantes: (\(lat), \(lon))&quot;)
    }
  }
}

let loc1 = Location.Address(city: &quot;Boston&quot;, street: &quot;33 Court St&quot;)
let loc2 = Location.Coordinates(lat: 42.3586, lon: -71.0590)

loc1.printOut() // Address: 33 Court St, Boston
loc2.printOut() // Coordiantes: (42.3586, -71.059)</code></pre><p>  枚举同时可以递归，通过indirect关键字来实现</p>
<pre><code>enum List {
    case Empty
    indirect
    case Cell(value: Int, next: List)
}

let list0 = List.Cell(value: 1, next: List.Empty)
let list1 = List.Cell(value: 4, next: list0)
let list2 = List.Cell(value: 2, next: list1)
let list3 = List.Cell(value: 6, next: list2)
let headL = List.Cell(value: 3, next: list3)

func evaluateList(list: List) - &gt; Int {
    switch list {
        case let.Cell(value, next):
            return value + evaluateList(next)
        case .Empty:
            return 0
    }
}

print(evaluateList(headL)) // 16</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Swift的函数语法是非常随意的，既可以像C语言风格的，也可以像Objective-C语言风格的。在Swift中，每个函数都有一个类型，它由函数的参数和返回值组成。这表示你能够指定函数的变量或者把函数作为参数传给另一个函数。</p>
<pre><code>func stringCharactersCount(s: String) -&gt; Int {
  return s.characters.count
}

func stringToInt(s: String) -&gt; Int {
  if let x = Int(s) {
    return x
  }
  return 0
}

func executeSuccessor(f: (String) -&gt; Int, s: String) -&gt; Int {
  return f(s)+1
}

let f1 = stringCharactersCount
let f2 = stringToInt

executeSuccessor(f: f1, s: &quot;5555&quot;) // 5
executeSuccessor(f: f2, s: &quot;5555&quot;) // 5556</code></pre><p>  Swift同时允许你定义一个函数参数的默认值。</p>
<pre><code>func myFunction(someInt: Int = 5) {
    // If no arguments are passed, the value of someInt is 5
}
myFunction(6) // someInt is 6
myFunction() // someInt is 5</code></pre><h3 id="Do关键字"><a href="#Do关键字" class="headerlink" title="Do关键字"></a>Do关键字</h3><p>do关键字允许你进入一个新的范围。</p>
<pre><code>let a = &quot;Yes&quot;

do {
  let a = &quot;No&quot;
  print(a) // No
}

print(a) // Yes</code></pre><p>do关键字同时允许包含一个或者多个catch分句。</p>
<pre><code>do {
   try expression
   statements
} catch pattern 1 {
   statements
} catch pattern 2 where condition {
   statements
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/08/Swift%E5%92%8CObjective-C%E7%9A%84%E5%8D%81%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%82%B9/" data-id="ck736a2qv001tees6bfdhdi6u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/" rel="tag">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/" rel="tag">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一次日志统计分析之旅" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/09/%E4%B8%80%E6%AC%A1%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B9%8B%E6%97%85/" class="article-date">
  <time datetime="2018-03-09T02:35:31.000Z" itemprop="datePublished">2018-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/09/%E4%B8%80%E6%AC%A1%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B9%8B%E6%97%85/">一次日志统计分析之旅</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着移动互联网、云计算、物联网的崛起与发展，大数据的时代已经来临。当数据量不停增长时，如何实时查询和分析业务的状况变的业务状况变的越来越重要。<br>本文主要包含以下几个方面：</p>
<ol>
<li>数据采集</li>
<li>消息队列</li>
<li>数据存储</li>
<li>离线分析</li>
</ol>
<p>当数据产生时，通过flume客户端去采集数据，然后放入kafka消息队列中，接着通过flume服务端去消费这个数据，最终把数据放入es、hbase、mongodb等数据库中。<br><img src="%E6%9E%B6%E6%9E%84.png" alt="架构"></p>
<h2 id="1-数据采集"><a href="#1-数据采集" class="headerlink" title="1. 数据采集"></a>1. 数据采集</h2><p>Flume是一个分布式的、高可用的日志收集系统。Flume-NG采用三层架构设计：收集（source）、暂存（channel）、处理（sink）。如图所示：<br><img src="flume.png" alt="event在agent中的传输过程"></p>
<h3 id="1-1-source"><a href="#1-1-source" class="headerlink" title="1.1 source"></a>1.1 source</h3><p>source用来对接各种数据源，将收集到的数据存入channel中。<br>常用的source类型有Avro source、Exec source、Kafka source等。<br>Avro source通过监听Avro端口接收外部客服端流事件，在flume多层架构中常被用来接收上层agent sink发送的event。<br>Kafka source用来对接分布式消息队列kafka，作为kafka的消费者持续从kafka中拉取数据。<br>Exec source收集标准输出数据或者通过tail -f file的方式监听指定文件。但是不支持断点续传（不记录读取文件的位置）。</p>
<h3 id="1-2-channel"><a href="#1-2-channel" class="headerlink" title="1.2 channel"></a>1.2 channel</h3><p>channel为event中的缓冲区，存储source收集并且没有被sink读取的event，平衡source收集和sink读取数据的速度，相当于flume内部的消息队列。<br>常用的channel类型有memory channel、file channel、kafka channel。<br>memory channel读写速度快，但是存储小，flume进程挂掉时，数据会丢失。<br>file channel将event写入磁盘文件，存储大，无数据丢失风险。<br>kafka channel将kafka作为channel存储。kafka channel相对于memory channel和file channel存储容量大，容错能力强。在日志收集层，可以只配置source组件和kafka channel组件，不需要再配置sink组件，可以减少日志收集层启动的进程数并且有效降低服务器内存、磁盘等资源使用率。再日志汇聚层，可以只配置kafka channel和sink，不需要再配置source，减少日志汇聚层的进程数，这样能降低服务器的资源利用率和减少event再网络之间的传输，有效提高日志采集系统的性能。</p>
<h3 id="1-3-sink"><a href="#1-3-sink" class="headerlink" title="1.3 sink"></a>1.3 sink</h3><p>avro sink常用来对接下一层的avro source，通过发送rpc请求将event发送到下一层的avro source。<br>hdfs sink用来将event写入hdfs文件存储。<br>kafka sink将evnet写入到kafka主题中。<br>本文采用exec source作为source，channel采用file channel，sink采用kafka sink。这样可以采集不同的数据源，然后分发到不同的kafka topic中。</p>
<h2 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h2><p>kafka是一个开源的分布式消息队列，具有高吞吐、可扩展、高可用的特性。<br><img src="kafka.png" alt="kafka架构图"><br>一个kafka集群可以有多个kafka实例，由zookeeper协调管理（保存kafka元数据、动态扩展、负载均衡）。一个kafka实例就是一个broker。broker中有包含topic，topic相当于一个数据库表，一个topic可以分为多个partition和多个replication。producer将同一类型的消息写入同一个topic中，consumer从同一个topic消费同一类型的数据。<br>kafka之所以能够实现高吞吐、可扩展、高可用，是因为它基于磁盘顺序读写（比内存读写性能还高），pagecache、sendfile技术（零拷贝）、多分区（一个分区代表一个线程）。</p>
<h2 id="3-数据存储"><a href="#3-数据存储" class="headerlink" title="3. 数据存储"></a>3. 数据存储</h2><p>flume服务端通过消费kafka中的topic，把日志写入到各个数据库中。</p>
<h3 id="3-1-HBase"><a href="#3-1-HBase" class="headerlink" title="3.1 HBase"></a>3.1 HBase</h3><p>HBase是一个分布式的、持久的、强一致性的存储系统，具有尽似最优的写性能和出色的读性能。HBase和传统型关系型数据库相比，就是使用了LSM树做为底层数据结构。LSM树以磁盘传输速率工作并能较好地扩展以处理大量的数据，它们使用日志文件和内存存储来将随机写转换成顺序写，因此也能保证稳定的数据插入速率。又由于读写独立，因此两种操作之间没有冲突。<br>Hbase中有3个主要组件：客户端库、一台主服务器和多台region服务器。region服务器可以根据负载的变化动态添加和移除。主服务器主要负责利用zookeeper为region服务器分配region。<br><img src="hbase.png" alt="hbase架构图"><br>主服务器不负责数据服务，只提供region管理和元数据的管理。region服务器提供读写服务。HBase主要处理两种文件，预写日志和实际的数据文件，两者由HRegionServer管理。<br>HBase中的行键设计非常重要，它是用来定位具体一行的数据的，通过行键的查询是最快的。但是如果按照特定序列来命名，容易造成region热点，在某一时间段数据全往一个region中写。一般通过加入salt或者哈希随机化来设计行键。但反过来，随机写带来的一个坏处是会造成顺序读的性能下降。</p>
<h3 id="3-2-Hive"><a href="#3-2-Hive" class="headerlink" title="3.2 Hive"></a>3.2 Hive</h3><p>Hive是一个建立在Hadoop架构上的数据仓库。它能够提供数据的精炼，查询和分析。它可以将结构化的数据文件映射为一张数据库表，并提供sql查询功能。<br>Hive可以映射hdfs或者hbase来建立外表，然后通过hql语句来查询相应的数据。同时可以按天建立分区表，减少查询的数据量。值得注意的是，外表以及通过外表建立的分区表，在删表时并不会删除数据。</p>
<h3 id="3-3-Elasticsearch"><a href="#3-3-Elasticsearch" class="headerlink" title="3.3 Elasticsearch"></a>3.3 Elasticsearch</h3><p>Elasticsearch是一款开源的、分布式的、restful风格的搜索引擎。它内部使用Lucene做索引与搜索。它有如下特点：</p>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务器节点的扩展，并支持PB级别的结构化或者非结构化的数据</li>
</ul>
<h2 id="4-离线分析"><a href="#4-离线分析" class="headerlink" title="4. 离线分析"></a>4. 离线分析</h2><p>Spark是一款开源的分布式大数据处理通用引擎，具有高吞吐、低延时、可扩展、高容错等特点。它包括离线计算、交互式查询、数据挖掘算法、流式计算及图计算。<br>Spark包含以下几个组件：<br><img src="spark%E7%BB%84%E4%BB%B6.png" alt="Spark组件"></p>
<h3 id="Apache-Spark-core"><a href="#Apache-Spark-core" class="headerlink" title="Apache Spark core"></a>Apache Spark core</h3><p>Apache Spark core是spark平台的核心组件，其他组件都依赖于它。它主要负责：</p>
<ul>
<li>内存管理和故障恢复</li>
<li>在集群上安排、分布和监控作业</li>
<li>和存储系统进行交互</li>
</ul>
<h3 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h3><p>Spark SQL是Spark Core之上的一个组件，它引入了一个称为SchemaRDD的新数据抽象，它为结构化和半结构化数据提供支持（Hive等）。<br><img src="spark-sql.png" alt="Spark SQL"><br>如果配置支持hive，当Spark SQL进行编程或者查询时，可以使用HiveSQL作为查询语言。</p>
<h3 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><p>Spark Streaming利用Spark Core的快速调度功能来执行流式分析。它以小批量获取数据，并对这些小批量的数据执行RDD（弹性分布式数据集）转换。</p>
<h3 id="MLib"><a href="#MLib" class="headerlink" title="MLib"></a>MLib</h3><p>MLlib是Spark之上的分布式机器学习框架，因为基于分布式内存的Spark架构。根据基准，它是由MLlib开发人员针对交替最小二乘法（ALS）实现完成的。 Spark MLlib是基于Hadoop磁盘的Apache Mahout版本的9倍（在Mahout获得了Spark接口之前）。</p>
<h3 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h3><p>GraphX是Spark上的一个分布式图形处理框架。它提供了一个用于表达图形计算的API，可以通过使用Pregel抽象API为用户定义的图形建模。它还为此抽象提供了一个优化的运行时。</p>
<p>相对于Hadoop，spark采用了DAG执行引擎，支持循环数据流和内存计算，在内存中的速度是hadoop的100倍，磁盘上的速度是hadoop的10倍。<br>Spark实现了DAG的计算模型，DAG计算模型是指将一个任务按照计算规则分解为若干子任务，这些子任务之间根据逻辑关系构建有向无环图。<br><img src="spark.png" alt="Spark架构图"><br>Spark计算操作都是基于RDD进行的。RDD具体只读、多分区、分布式的特性。外部的文件系统的文件如hbase，hdfs都可以转换为RDD。同时一个或者多个RDD可以转换为新的RDD。<br>RDD提供Transformation和Action两种计算类型。Transformation的操作只有当Action的时候才会真正的执行操作。同时RDD可以缓存到内存或者磁盘中，这样可以减少网络传输次数，提高spark的计算性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/09/%E4%B8%80%E6%AC%A1%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B9%8B%E6%97%85/" data-id="ck736a2r0002bees679j2gfo1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flume/" rel="tag">Flume</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Category与Extension" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/30/Category%E4%B8%8EExtension/" class="article-date">
  <time datetime="2018-01-30T01:43:17.000Z" itemprop="datePublished">2018-01-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/30/Category%E4%B8%8EExtension/">Category与Extension</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Objective-C中，要扩展一个类的方法，首先想到的应该是继承，这是面向对象语言的一个特性。继承可以很方便的增加方法，属性等，同时还可以覆写父类的方法。但是，对于大型而复杂的类，继承会导致维护困难。这时Category就可以发挥作用了。</p>
<h2 id="什么是Category"><a href="#什么是Category" class="headerlink" title="什么是Category"></a>什么是Category</h2><p>Category是Objective-C 2.0之后添加的语言特性，其主要作用是为已经存在的类添加方法。通过它，你可以</p>
<ul>
<li>把代码分散到多个类中-比如把类中的不同模块的方法放入几个不同的category中。</li>
<li>申明私有方法。</li>
<li>模拟多继承。</li>
<li>公开framework的私有方法。</li>
</ul>
<h2 id="Category的使用注意"><a href="#Category的使用注意" class="headerlink" title="Category的使用注意"></a>Category的使用注意</h2><p>因为谁都可以扩展一个类，所以在使用Category时有几点需要注意的地方。</p>
<p>比如你的应用扩展了NSString类，同时你链接的第三方库也扩展了NSString类。刚好两者扩展了一个相同的方法名。由于Category是在runtime时实现的，这是加载哪个实现是不确定的，从而会导致不确定的结果。</p>
<p>又比如你扩展了<code>NSSortDescriptor</code>类，增加了一个<code>sortDescriptorWithKey:ascending:</code>方法。在低版本的iOS中这个方法是不存在的，但是高版本的iOS中，这个方法是默认被实现的。这时就会有一个命名冲突。</p>
<p>因此为了避免上述的情况，建议是在扩展类的方法名前加入前缀。比如：</p>
<pre><code>@interface NSSortDescriptor (XYZAdditions)
+ (id)xyz_sortDescriptorWithKey:(NSString *)key ascending:(BOOL)ascending;
@end</code></pre><h2 id="Category与Extension的区别"><a href="#Category与Extension的区别" class="headerlink" title="Category与Extension的区别"></a>Category与Extension的区别</h2><p>Extension像一个匿名的Category，但是两者差别很大。Extension只能附加在源码的类上面，它是编译时决定的，从而可以添加实例变量。而Category是在运行时决定的，内存布局已经确定，从而不可以添加实例变量。Extension常用来隐藏实现细节，比如不想对外公开的方法和实例变量等。</p>
<h2 id="Category源码实现"><a href="#Category源码实现" class="headerlink" title="Category源码实现"></a>Category源码实现</h2><p>通过查看runtime源码，发现category实际上是一个叫做category_t的结构体</p>
<pre><code>typedef struct category_t {
  const char *name;
  classref_t cls;
  struct method_list_t *instanceMethods;
  struct method_list_t *classMethods;
  struct protocol_list_t *protocols;
  struct property_list_t *instanceProperties;
}</code></pre><p>从中我们可以发现，它可以添加实例方法、类方法、协议、实例属性。<br>接下去我们看一下category是如何加载的。</p>
<pre><code>void _objc_init(void) {
  ...
  dyld_register_image_state_change_handler(dyld_image_state_bound,
                                     1/*batch*/, &amp;map_2_images);
  ...
}</code></pre><p>首先通过runtime的入口函数<code>_objc_init</code>方法中加载<code>map_2_images</code>。</p>
<pre><code>const char * map_2_images(enum dyld_image_states state, uint32_t infoCount,
         const struct dyld_image_info infoList[])
{
    rwlock_writer_t lock(runtimeLock);
    return map_images_nolock(state, infoCount, infoList);
}</code></pre><p>然后<code>map_2_images</code>通过加锁访问<code>map_images_nolock</code>。</p>
<pre><code>const char *map_images_nolock(enum dyld_image_states state, uint32_t infoCount,
            const struct dyld_image_info infoList[])
{
  ...
  _read_images(hList, hCount);
  ...
}</code></pre><p>在这里通过<code>_read_images</code>去读取image。</p>
<pre><code>void _read_images(header_info **hList, uint32_t hCount)
{
  ...
  // Discover categories.
  for (EACH_HEADER) {
    category_t **catlist =
      _getObjc2CategoryList(hi, &amp;count);
      for (i = 0; i &lt; count; i++) {
        category_t *cat = catlist[i];
        Class cls = remapClass(cat-&gt;cls);
        ...
        // Process this category.
        // First, register the category with its target class.
        // Then, rebuild the class&apos;s method lists (etc) if
        // the class is realized.
        bool classExists = NO;
        if (cat-&gt;instanceMethods ||  cat-&gt;protocols  
          ||  cat-&gt;instanceProperties)
        {
          addUnattachedCategoryForClass(cat, cls, hi);
          if (cls-&gt;isRealized()) {
              remethodizeClass(cls);
              classExists = YES;
          }
          ...
        }

        if (cat-&gt;classMethods  ||  cat-&gt;protocols  
          /* ||  cat-&gt;classProperties */)
        {
          addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);
          if (cls-&gt;ISA()-&gt;isRealized()) {
              remethodizeClass(cls-&gt;ISA());
          }
          ...
        }
      }
    }
    ...
}</code></pre><p>上述代码执行的操作就是找到相应的category，分别把category的实例方法、协议、属性加入到类上，类方法、协议添加到元类上面。首先注册category到目标类上去，然后如果类或则元类已经实现，则重构它的方法列表。<br>具体的执行是<code>addUnattachedCategoryForClass</code>和<code>remethodizeClass</code>方法。</p>
<pre><code>static void addUnattachedCategoryForClass(category_t *cat, Class cls,
                                          header_info *catHeader)
{
    runtimeLock.assertWriting();

    // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead
    NXMapTable *cats = unattachedCategories();
    category_list *list;

    list = (category_list *)NXMapGet(cats, cls);
    if (!list) {
        list = (category_list *)
            calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1);
    } else {
        list = (category_list *)
            realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1));
    }
    list-&gt;list[list-&gt;count++] = (locstamped_category_t){cat, catHeader};
    NXMapInsert(cats, cls, list);
}</code></pre><p><code>addUnattachedCategoryForClass</code>方法把类和category做了一个关联映射。</p>
<pre><code>static void remethodizeClass(Class cls)
{
...
attachCategories(cls, cats, true /*flush caches*/);        
...
}</code></pre><p>而<code>remethodizeClass</code>方法内部其实调用了<code>attachCategories</code>方法。<code>attachCategories</code>方法是真正把category里面的东西加入到类中去。</p>
<pre><code>static void
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
...
while (i--) {
    auto&amp; entry = cats-&gt;list[i];

    method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);
    if (mlist) {
        mlists[mcount++] = mlist;
        fromBundle |= entry.hi-&gt;isBundle();
    }

    property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta);
    if (proplist) {
        proplists[propcount++] = proplist;
    }

    protocol_list_t *protolist = entry.cat-&gt;protocols;
    if (protolist) {
        protolists[protocount++] = protolist;
    }
}

auto rw = cls-&gt;data();
prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
rw-&gt;methods.attachLists(mlists, mcount);
free(mlists);
if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);

rw-&gt;properties.attachLists(proplists, propcount);
free(proplists);

rw-&gt;protocols.attachLists(protolists, protocount);
free(protolists);
}</code></pre><p>从中我们可以看到，这里把category中的方法、属性、协议添加到原有的类上面。</p>
<blockquote>
<p>这里说明一下，category中的方法并不会覆盖原有的方法，如果存在两个相同的方法。但是由于category中的方法是放在前面的，所以在消息转发查找方法时会先找到category的方法，从而形成了覆盖原有方法的错觉。</p>
</blockquote>
<h2 id="Category与-load"><a href="#Category与-load" class="headerlink" title="Category与+load()"></a>Category与+load()</h2><p>runtime在加载类和分类时，是通过调用各自的指针分开加载的，因此既会执行类的<code>+load()</code>方法，也会执行分类的<code>+load()</code>方法。但是当我们手动调用<code>+load()</code>方法时，则分类的<code>+load()</code>方法会先于类的<code>+load()</code>方法，并造成覆盖的错觉。测试代码如下：</p>
<pre><code>#import &quot;Person.h&quot;

@implementation Person

+ (void)load {
  NSLog(@&quot;main load&quot;);
}

@end

@implementation Person (Fly)

+ (void)load {
  NSLog(@&quot;category load&quot;);
}

- (void)fly {
  NSLog(@&quot;I can fly&quot;);
}

- (void)jump {
  NSLog(@&quot;I can jump&quot;);
}

@end


#import &quot;ViewController.h&quot;
#import &quot;Person.h&quot;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    [Person load];
}

@end</code></pre><p>结果如下：</p>
<pre><code>2018-01-30 17:02:44.442283+0800 CategoryDemo[23354:4396068] main load
2018-01-30 17:02:44.442758+0800 CategoryDemo[23354:4396068] category load
2018-01-30 17:02:44.599671+0800 CategoryDemo[23354:4396068] category load</code></pre><p>从结果中可知先调用了类的<code>+load()</code>方法，再调用了分类的<code>+load()</code>方法。最后主动调用时，调用了分类的<code>+load()</code>方法。</p>
<h2 id="Category与实例变量"><a href="#Category与实例变量" class="headerlink" title="Category与实例变量"></a>Category与实例变量</h2><p>从源码中可知，category是无法添加实例变量的。但是有时往往需要实例变量，这时可以通过runtime关联对象做一个假的实例变量。</p>
<pre><code>-------------------------------
@interface Person (Fly)

@property(nonatomic,copy) NSString *name;

@end


-------------------------------
static NSString *associateKey = @&quot;name&quot;;

@implementation Person (Fly)


- (void)setName:(NSString *)name {
  objc_setAssociatedObject(self, &amp;associateKey, name, OBJC_ASSOCIATION_COPY);
}

- (NSString *)name {
  return objc_getAssociatedObject(self, &amp;associateKey);
}

@end</code></pre><p>然后我们分析一下<code>objc_setAssociatedObject</code>的源码。</p>
<pre><code>void objc_setAssociatedObject(id object, const void *key, id value,
                     objc_AssociationPolicy policy)
{
  ObjcAssociation old_association(0, nil);
  id new_value = value ? acquireValue(value, policy) : nil;
  {
      AssociationsManager manager;
      AssociationsHashMap &amp;associations(manager.associations());
      disguised_ptr_t disguised_object = DISGUISE(object);
      if (new_value) {
        ...
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        ObjectAssociationMap *refs = i-&gt;second;
        ObjectAssociationMap::iterator j = refs-&gt;find(key);
        (*refs)[key] = ObjcAssociation(policy, new_value);
        ...
      }
      ...
  }
  ...   
}</code></pre><p>从中可以发现，这个<code>associateObject</code>是由<code>AssociationsManager</code>管理的，<code>AssociationsManager</code>里面有一个<code>AssociationsHashMap</code>的哈希表，用来存储所有的object，其key值为这个objcet的地址。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="noopener">1.Category</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW2" target="_blank" rel="noopener">2.Customizing Existing Classes</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/" target="_blank" rel="noopener">3.Objective-C Category 的实现原理
</a><br><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">4.深入理解Objective-C：Category
</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/30/Category%E4%B8%8EExtension/" data-id="ck736a2q00008ees6cvjghm2h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/" rel="tag">Objective-C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-解析objc-msgSend-ARM64" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/29/%E8%A7%A3%E6%9E%90objc-msgSend-ARM64/" class="article-date">
  <time datetime="2018-01-29T15:54:39.000Z" itemprop="datePublished">2018-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/29/%E8%A7%A3%E6%9E%90objc-msgSend-ARM64/">解析objc_msgSend(ARM64)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>每个Objective-C对象都有相应的类，这个类都有一个方法列表。类中的每个方法都有一个选择子、一个指向方法实现的函数指针和一些元数据。<code>objc_msgSend</code>的工作就是通过传入的对象和选择子，查找相应方法的函数指针，然后跳转到该函数指针。</p>
<p>查找方法的流程是非常复杂的。如果这个方法没有在对应的类上被找到，就会到该类的父类中去查询。如果所有类都没有这个方法，那么就会调用runtime消息中的<code>forwarding</code>代码。如果这是发送到该类上的第一条消息，就同时会调用该类的<code>+initialize</code>方法。</p>
<p>但是在一般情况下，查询方法需要非常快，因为有成千上万次查询。这就与前面复杂的查找过程相矛盾了。</p>
<p>Objective-C解决这个冲突的方法是方法缓存。每个类都有一个方法缓存，它将方法存储为选择子和函数指针的键值对，这个函数指针在Objective-C中被称为<code>IMPS</code>。这个选择子和函数指针键值对被存为一个哈希表，所以查找速度很快。查找方法时，<code>runtime</code>首先查询缓存。如果方法不在缓存中，则进入相对慢且复杂的进一步查询。查到之后会将结果放入缓存中，这样下一次查询更快。</p>
<p><code>objc_msgSend</code>是用汇编写的。原因有二：一是不能编写保留未知参数的函数，并跳转到C中的任意函数指针。C语言没有必要的特性来做这样的事情。二是<code>objc_msgSend</code>需要保证快速的查询，那就需要直接操作指令来保证。</p>
<p>当然，你不需要用汇编语言编写整个复杂的消息查找程序。<code>objc_msgSend</code>的代码可以分为两部分：一是<code>objc_msgSend</code>缓存查询，它是用汇编写的，二是分级查询，是用C实现的。汇编部分在高速缓存中查找方法，如果发现该方法就跳转到该方法上。如果该方法不在缓存中，则调用C代码来处理进一步的查询。</p>
<p>总的来说，在调用<code>objc_msgSend</code>时会执行以下操作：</p>
<ol>
<li>获取传入的对象的类。</li>
<li>获取该类的方法缓存。</li>
<li>使用传入的选择器来查找缓存中的方法。</li>
<li>如果不在缓存中，则调用C代码。</li>
<li>跳转到该方法的IMP。</li>
</ol>
<h2 id="用汇编查询缓存"><a href="#用汇编查询缓存" class="headerlink" title="用汇编查询缓存"></a>用汇编查询缓存</h2><p><code>objc_msgSend</code>根据具体情况可以采取不同的查询策略，比如消息发送到<code>nil</code>、标记的指针(<a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">tagged pointers</a>)和哈希表的冲突等情况。首先看看最常见的情况：即将消息发送到非<code>nil</code>非标记指针，同时在高速缓存中找到了该方法，而无需进行进一步扫描查询。对于其他的特殊情况，我们在分析完常见情形时再来分析。</p>
<p>在这里，每条指令前面都有一个从函数开始的偏移量。这作为一个计数器，让你识别跳转目标。</p>
<p><code>ARM64</code>有31个整型寄存器，从<code>x0</code>到<code>x31</code>，它们是64位的。同时也可以使用<code>w0</code>到<code>w30</code>访问每个寄存器的低32位，就像它是一个单独的寄存器一样。寄存器<code>x0</code>到<code>x7</code>用于将前8个参数传递给函数。这意味着objc_msgSend接收<code>x0</code>中的<code>self</code>参数和<code>x1</code>中的选择子<code>_cmd</code>参数。</p>
<p>让我们开始！</p>
<pre><code>0x0000 cmp     x0, #0x0
0x0004 b.le    0x6c</code></pre><p>如果<code>self(x0)</code>小于等于0，则跳转到别处。0代表<code>nil</code>，则处理message发送到nil的特殊情况。这里同时也处理标记指针。在<code>ARM64</code>上标记指针设置高32位(在<code>x86-64</code>上是低32位)。如果设置了高位，那么对于有符号整数时，该值为负。对于<code>self</code>是普通指针的常见情况，将不会进入该分支。</p>
<pre><code>0x0008 ldr    x13, [x0]</code></pre><p>通过加载<code>x0</code>来加载<code>self</code>的<code>isa</code>，其中包含<code>self</code>。现在<code>x13</code>寄存器包含<code>isa</code>。</p>
<pre><code>0x000c and    x16, x13, #0xffffffff8</code></pre><p>ARM64可以使用<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">非指针的isas</a>。传统上<code>isa</code>指向对象的类，而非指针<code>isa</code>则通过空闲位将一些其他信息填充到<code>isa</code>中来。该指令执行一个逻辑与来过滤所有的额外位信息，并将实际的类指针信息放入<code>x16</code>中。</p>
<pre><code>0x0010 ldp    x10, x11, [x16, #0x10]</code></pre><p>它将类的缓存信息加载到<code>x10</code>和<code>x11</code>中。 <code>ldp</code>指令将两个寄存器的内存数据加载到前两个参数中指定的寄存器中。第三个参数描述了从哪里加载数据，在这里，从<code>x16</code>的偏移量16(十进制)的位置开始，这是类中保存高速缓存信息的区域。缓存结构体代码如下：</p>
<pre><code>typedef uint32_t mask_t;

struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
}</code></pre><p>从<code>ldp</code>指令看，<code>x10</code>储存<code>_buckets</code>的值，而<code>x11</code>的高32位存储<code>_occupied</code>的值，低32位存储<code>_mask</code>的值。</p>
<p><code>_occupied</code>字段表示哈希表包含多少条目，在<code>objc_msgSend</code>中不起作用。 <code>_mask</code>字段非常重要：它将哈希表的大小描述为一个掩码，值始终是2的幂减1，像000000001111111这种二进制形式。这个值用来计算选择子的查找索引，同时可以在查询列表时返回到列表末端。</p>
<pre><code>0x0014 and    w12, w1, w11</code></pre><p>该指令找寻以<code>_cmd</code>形式传入的选择子在哈希始表中的索引。<code>x1</code>包含<code>_cmd</code>，所以<code>w1</code>包含<code>_cmd</code>的低32位。 <code>w11</code>包含如上所述的<code>_mask</code>。该指令将两者逻辑与后放入<code>w12</code>。这个结果相当于<code>_cmd</code> ％ <code>table_size</code>的值。</p>
<pre><code>0x0018 add    x12, x10, x12, lsl #4</code></pre><p>要想从哈希表中加载数据，需要知道其实际地址，因此只有索引还不够。该指令将左移4位的哈希表索引和<code>bucket</code>地址相加后赋值给<code>x12</code>，因为每个哈希表<code>bucket</code>都是16字节。现在<code>x12</code>指向了要搜索的第一个<code>bucket</code>的地址。</p>
<pre><code>0x001c ldp    x9, x17, [x12]</code></pre><p>该指令加载<code>x12</code>(当前<code>bucket</code>)的地址给<code>x9</code>和<code>x17</code>。每个<code>bucket</code>包含一个选择子和一个<code>IMP</code>。 <code>x9</code>现在指向当前<code>bucket</code>的选择子，<code>x17</code>指向当前<code>bucket</code>的<code>IMP</code>。</p>
<pre><code>0x0020 cmp    x9, x1
0x0024 b.ne   0x2c</code></pre><p>这些指令将<code>x9</code>中的选择子与<code>x1</code>中的<code>_cmd</code>进行比较。如果它们不匹配，那么当前的<code>bucket</code>不包含我们正在查找的选择子。在这种情况下，第二条指令跳转到偏移<code>0x2c</code>，用来处理不匹配的<code>bucket</code>。如果匹配到选择子，那么就找到了正在查找的条目，并继续执行下一条指令。</p>
<pre><code>0x0028 br    x17</code></pre><p>这里无条件跳转到<code>x17</code>，它包含当前<code>bucket</code>加载的<code>IMP</code>。在这里执行实际的目标方法的实现函数，同时也是<code>objc_msgSend</code>的快速查询的最终阶段。由于所有参数寄存器都不受干扰，因此目标方法将接收所有传入的参数，就如同直接调用一样。<br>当所有的方法都被缓存后，在如今的硬件设备上快速查询的时间会小于3纳秒。</p>
<p>接着让我们看一下没有匹配到缓存(<code>bucket</code>)的代码逻辑。</p>
<pre><code>0x002c cbz    x9, __objc_msgSend_uncached</code></pre><p>x9包含从<code>bucket</code>中加载的选择子。该指令将其与0进行比较，如果为0，则跳转到<code>__objc_msgSend_uncached</code>。没有选择子代表<code>bucket</code>是空的，也就是搜索失败。如果目标方法不在高速缓存中，就需要执行C代码来进行更全面查找。</p>
<pre><code>0x0030 cmp    x12, x10
0x0034 b.eq   0x40</code></pre><p>该指令比较<code>x12</code>中的当前<code>bucket</code>地址与<code>x10</code>中的哈希表的起始地址。如果匹配，则跳转到<code>0x40</code> 。<br>在这里执行的哈希表搜索实际上是反向运行的。搜索从末尾到起始地址。</p>
<pre><code>0x0038 ldp    x9, x17, [x12, #-0x10]!</code></pre><p><code>ldp</code>加载当前<code>bucket</code>的地址偏移<code>0x10</code>的地址，也就是上一个<code>bucket</code>地址，并赋值给<code>x9</code>和<code>x17</code>。地址末尾的感叹号表示寄存器写回，是用新值更新旧值。</p>
<pre><code>0x003c b      0x20</code></pre><p>这里循环跳会上面的<code>0x0020</code>的指令。也就是不停的对比<code>bucket</code>，直到找到一个相同的<code>bucket</code>，或者一直没找到直到哈希表的开始位置。</p>
<pre><code>0x0040 add    x12, x12, w11, uxtw #4</code></pre><p>跳转到<code>0x0040</code>是，<code>x12</code>已经指向哈希表的开始， 而<code>w11</code>表示哈希表的掩码，也就是表的大小。将<code>w11</code>左移4位后将这两者相加，结果是新的<code>x12</code>再次指向表的末尾。再次从尾到头进行搜索。</p>
<pre><code>0x0044 ldp    x9, x17, [x12]</code></pre><p>现在<code>ldp</code>将新的bucket载入<code>x9</code>和<code>x17</code>。</p>
<pre><code>0x0048 cmp    x9, x1
0x004c b.ne   0x54
0x0050 br     x17</code></pre><p>该代码检查当前<code>bucket</code>于传入的<code>_cmd</code>否匹配，匹配跳转到<code>bucket</code>的IMP，不匹配跳转到<code>0x54</code>。这是上面<code>0x0020</code>代码的重复。</p>
<pre><code>0x0054 cbz    x9, __objc_msgSend_uncached</code></pre><p>就像之前一样，如果<code>bucket</code>是空的，那么这是一个缓存未命中并且执行C实现的综合查找代码。</p>
<pre><code>0x0058 cmp    x12, x10
0x005c b.eq   0x68</code></pre><p>接着再次检查当前的<code>bucket</code>是否到了哈希表的起始，如果再次运行到表的起始，则跳转到<code>0x68</code>。在这种情况下，它跳转到C代码的全面查找：</p>
<pre><code>0x0068 b      __objc_msgSend_uncached</code></pre><p>那为什么会出现这个重新扫描呢？源码的解释如下：<br>当缓存损坏时，克隆扫描循环而不是挂起循环。全面查找时可能会检测到任何损坏并在稍后停止这个循环。<br>这种情况不常见，但显然苹果开发人员看到由于内存损坏导致缓存充满了损坏的内容，并跳转到C代码来提高诊断。<br>这个再次检查对正常的代码应该影响很小。没有它，原来的循环可以被重用，这将节省一些指令缓存空间，但只节省一点点。只有对于在哈希表起始附近的选择子，同时发生冲突并且所有先前的条目被占用时，重新扫描才会被调用。</p>
<pre><code>0x0060 ldp    x9, x17, [x12, #-0x10]!
0x0064 b      0x48</code></pre><p>这个循环的其余部分与之前一样。将下一个<code>bucket</code>加载到<code>x9</code>和<code>x17</code>中，更新<code>x12</code>中的<code>bucket</code>指针，然后返回到循环的顶部。</p>
<p>这样<code>objc_msgSend</code>主体就结束了。那么nil和标记指针的特殊情况是如何的呢？</p>
<h2 id="标记指针-Tagged-Pointer-的处理"><a href="#标记指针-Tagged-Pointer-的处理" class="headerlink" title="标记指针(Tagged Pointer)的处理"></a>标记指针(Tagged Pointer)的处理</h2><p>你可能回忆起在指令最开始的检查，跳转到<code>0x6c</code>来处理这种情况。</p>
<pre><code>0x006c b.eq    0xa4</code></pre><p>进入这个逻辑是因为<code>self</code>小于等于0。小于0表示一个标记指针，等于0表示为nil。这两种情况的处理是完全不同的。首先检查是第一种情况还是第二种情况。如果等于0跳转到<code>0xa4</code>。如果不是，继续执行下一条指令。</p>
<p>先简要的说明一下标记指针是如何工作的。标记指针(ARM64)的高4位指明这个对象属于哪个类。这对于标记指针的<code>isa</code>是必要的。当然，4bit几乎不足以拥有一个类指针。因此，有一张特殊的表来存储可用的标记指针类。一个标记指针对象的类通过高4位来查询这张表中的相应的类。</p>
<p>继续。</p>
<pre><code>0x0070 mov    x10, #-0x1000000000000000</code></pre><p>这条指令设置<code>x10</code>的高4位都为1，其他都为0。</p>
<pre><code>0x0074 cmp    x0, x10
0x0078 b.hs   0x90</code></pre><p>然后看<code>x0</code>是否大于等于<code>x10</code>，如果大于等于则表明是标记指针，则跳到<code>0x90</code>处理额外的类。否则，就直接使用主标记指针表(primary tagged pointer table)。</p>
<pre><code>0x007c adrp   x10, _objc_debug_taggedpointer_classes@PAGE
0x0080 add    x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</code></pre><p><code>_objc_debug_taggedpointer_classes</code>是主标记指针表。ARM64需要两条指令加载一个符号地址，因为ARM64是64位的，而指令仅只有32位。因此不可能用一条指令来表示一个完整的指针。<br>x86就不会遇到这个问题，因为它有变长的指令。对于定长指令的机器，需要分片加载。</p>
<pre><code>0x0084 lsr    x11, x0, #60</code></pre><p>标记类的索引在<code>x0</code>中的高4位，为了作为索引使用，需要右移60位，使它的范围变为0-15。这条指令把结果存入<code>x11</code>。</p>
<pre><code>0x0088 ldr    x16, [x10, x11, lsl #3]</code></pre><p>这条指令通过索引来加载主标记指针表中的标记指针。现在<code>x16</code>包含这个类的标记指针。</p>
<pre><code>0x008c b      0x10</code></pre><p>当<code>x16</code>包含了这个类的标记指针时，就可以返回到上面主分支代码的<code>0x10</code>。</p>
<pre><code>0x0090 adrp   x10, _objc_debug_taggedpointer_ext_classes@PAGE
0x0094 add    x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</code></pre><p>额外的标记类处理起来类似。两条指令加载一个指向额外表的指针。</p>
<pre><code>0x0098 ubfx   x11, x0, #52, #8</code></pre><p>这条指令加载额外的类索引。它从<code>self</code>中提取52位中的前8位到<code>x11</code>。</p>
<pre><code>0x009c ldr    x16, [x10, x11, lsl #3]</code></pre><p>像之前一样，利用索引来找寻表中的类，并赋值给<code>x16</code>。</p>
<pre><code>0x00a0 b      0x10</code></pre><p>得到了<code>x16</code>，就可以继续回到主分支代码执行<code>0x10</code>。</p>
<h2 id="nil处理"><a href="#nil处理" class="headerlink" title="nil处理"></a>nil处理</h2><p>终于到了nil的处理逻辑。以下是全部指令：</p>
<pre><code>0x00a4 mov    x1, #0x0
0x00a8 movi   d0, #0000000000000000
0x00ac movi   d1, #0000000000000000
0x00b0 movi   d2, #0000000000000000
0x00b4 movi   d3, #0000000000000000
0x00b8 ret</code></pre><p><code>nil</code>的处理是完全不同的，它没有类查询和方法分发。它做的只是返回0给调用者。</p>
<p>实际上<code>objc_msgSend</code>不知道调用者期望哪一种返回值。是返回一个整数、两个整数或者浮点值呢，还是什么都没有返回？</p>
<p>幸好，寄存器可以被安全的重写。整数存在<code>x0</code>和<code>x1</code>中，浮点数存在<code>v0</code>-<code>v3</code>中。多个寄存器被用来返回一个小的结构体。</p>
<p>代码清空了<code>x1</code>和<code>v0</code>-<code>v3</code>。<code>d0</code>-<code>d3</code>表示<code>v0</code>-<code>v3</code>的低32位。因此<code>movi</code>在这清空了上述4个寄存器。这之后，返回<code>ret</code>给调用者。</p>
<p>你可以会问为什么不清空<code>x0</code>。因为<code>x0</code>在这时本身就是空的，所以就不需要清空。</p>
<p>如果需要返回一个大的结构体，而现有的寄存器无法满足呢？这需要调用者的合作。大的结构体返回需要调用者申请足够大的内存。<code>objc_msgSend</code>不能清空内存，因为它不知道返回值有多大。为解决这个问题，在调用<code>objc_msgSend</code>之前，编译器自动生成代码把内存都填充为0。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>探究框架的内部实现往往是非常有趣的。通过阅读源码，可以看到<code>objc_msgSend</code>极具艺术性且实现的非常优雅。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html" target="_blank" rel="noopener">Dissecting objc_msgSend on ARM64</a><br><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Cjahjhee.html" target="_blank" rel="noopener">arm</a><br><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">Non-pointer isa</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/29/%E8%A7%A3%E6%9E%90objc-msgSend-ARM64/" data-id="ck736a2r7002uees6gi6847oq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/" rel="tag">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C-Runtime中的并发内存释放" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/29/Objective-C-Runtime%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/" class="article-date">
  <time datetime="2018-01-29T15:54:29.000Z" itemprop="datePublished">2018-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/29/Objective-C-Runtime%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/">Objective-C Runtime中的并发内存释放</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Mac和iOS代码中的核心是Objective runtime机制，而runtime的核心是objc_msgSend方法，objc_msgSend的核心是方法缓存机制。今天我们将探索Apple如何在线程安全的情况下改变方法缓存内存的大小和释放，而同时又不影响性能。</p>
<h2 id="消息发送概念"><a href="#消息发送概念" class="headerlink" title="消息发送概念"></a>消息发送概念</h2><p>objc_msgSend的工作原理就是为发送的方法找寻到适合的方法实现，并跳转到这个方法实现上。伪码大致如下：</p>
<pre><code>IMP loopUp(id obj, SEL selector) {
    Class cls = object_getClass(obj);

    while(cls) {
        for(int i=0; i&lt;cls-&gt;numMethods; i++) {
            Method m = c-&gt;methods [i];
            if (m.selector == selector) {
                return m.imp;
            }
        }
        cls = cls-&gt;superClass;
    }
    return _objc_msgForward;
}</code></pre><h2 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h2><p>如果寻找一个方法的实现是全局搜索，那么必将是非常慢的。方法缓存就是解决方法，它把用过的方法存到哈希表中。每个类存一个哈希表，这张表中存有方法和和对应的实现。objc_msgSend使用汇编语言快速搜索这个哈希表，这个搜索的事件数量级是纳秒级的。当然第一次由于没有缓存，所以会比较慢。但是第二次有了缓存之后将会非常快。</p>
<p>一提到缓存，一般就指的是快速获得最近使用的资源的有限内存。比如说，图片缓存，从网络上获取到图片后，一般会缓存下来。等到下次使用的时候，就不用从网络上获取，而直接从缓存中获取。而且这个缓存会有大小限制，因此到达限制后，新图片会替换最老的图片。</p>
<p>这对很多问题是一种解决方法，但是它会有一些性能问题。比如，缓存是40张图片，但是刚好你的应用经常用到第41张新图片，这样缓存就会变得不怎么有效。</p>
<p>如果是我们自己的应用，我们可以调节缓存的大小来应对这种问题。但是Objective-C runtime却无法这样做。因为方法缓存对性能是非常重要的，所以runtime没有对缓存大小做限制并会扩展缓存大小来缓存所有被发送的方法。</p>
<h2 id="大小改变、释放和线程"><a href="#大小改变、释放和线程" class="headerlink" title="大小改变、释放和线程"></a>大小改变、释放和线程</h2><p>改变缓存的大小从概念上来讲非常简单。伪码如下：</p>
<pre><code>bucket_t *newCache = malloc(newSize);
copyEntries(newCache, class-&gt;cache);
free(class-&gt;cache);
class-&gt;cache = newCache;</code></pre><p>Objective-C runtime中的实现其实更加简单，它没有复制旧缓存的内容到新缓存中去。毕竟，它只是一个缓存，没必要保留其中的数据。因此，伪码变成下面这样：</p>
<pre><code>free(class-&gt;cache);
class-&gt;cache = malloc(newSize);</code></pre><p>上面的代码对于单线程环境来说是足够了。但是Objective-C runtime是支持多线程的，这就需要确保所有的代码都是线程安全的。任何类的缓存在任何时候都有可能被多个线程同时获取，因此代码必须要处理到这种场景。</p>
<p>正如上面所说，存在这样一种场景，一个线程在释放旧缓存之后和指派新缓存之前这段时间内，另一个线程如果来读取，会读到一个无效的缓存指针。这会导致它只指向垃圾数据或者直接闪退。</p>
<p>我们如何解决这个问题呢？典型的做法就加锁。伪码如下：</p>
<pre><code>lock(class-&gt;lock);
free(class-&gt;cache);
class-&gt;cache = malloc(newSize);
unlock(class-&gt;lock);</code></pre><p>这样读写操作前必须获得锁。但是这意味着objc_msgSend必须获得锁，查询缓存，释放锁。每次都获得和释放锁会极大降低性能，毕竟查询缓存的时间是纳秒级的。</p>
<p>我们想着以其他方式去避免这种场景。比如，假如我们先申请和指派新的内存，然后释放旧的缓存？</p>
<pre><code>bucket_t *oldCache = class-&gt;cache;;
class-&gt;cache = malloc(newSize);
free(oldCache);</code></pre><p>这样也许有一点帮助，但这并不能解决问题。另一个线程可能取回一个旧的缓存指针，然后它在获得内容之前被系统回收。旧的缓存在另一个线程再一次跑起来之前被释放，引起之前相同的问题。</p>
<p>那么延迟释放呢？比如：</p>
<pre><code>bucket_t *oldCache = class-&gt;cache;;
class-&gt;cache = malloc(newSize);
after ( 5, ^{
    free(oldCache);
});</code></pre><p>这样也同样会产生上面那个问题，只是刚好发生在5s后。</p>
<p>如果定死一个时间延迟释放不好的，那就一直等待知道不出现这种场景。让我们增加一个计数器，伪码如下：</p>
<pre><code>gInMsgSend++;
lookUpCache(class-&gt;cache);
gInMsgSend--;</code></pre><p>如果考虑到线程安全的话，这个计数器得是atomic。</p>
<p>使用计数器的话，缓存重新申请的伪码应该是这样：</p>
<pre><code>bucket_t *oldCache = class-&gt;cache;
class-&gt;cache = malloc(newSize);
while(gInMsgSend)
    ;  //spin
free(oldCache);</code></pre><p>值得注意的是此时不需要阻塞objc_msgSend的执行。只要缓存释放代码在替换了旧缓存指针之后，就可以确认在objc_msgSend在任何时刻都是空的。它能够继续释放旧的缓存指针。另一个线程可能在旧缓存指针被释放的时候调用objc_msgSend，但是这个新的调用不可能看到旧的指针，因此它是安全的。</p>
<p>不停的循环可能效率不高和不够优雅。没必要急着释放旧的缓存。在不耗费大量时间的情况下释放这些内存会比较好。让我们保持一个没有释放的旧缓存列表，同时每次空闲下来时，就尝试释放所有列表中的旧缓存。</p>
<pre><code>bucket_t *oldCache = class-&gt;cache;
class-&gt;cache = malloc(newSize);
append(gOldCacheList, oldCache);
if(!gInMsgSend) {
    for (cache in gOldCacheList) {
        free(cache);
    }
    gOldCacheList.clear();
}</code></pre><p>以上的版本跟Objective runtime的实现非常接近。</p>
<h2 id="零花费标识"><a href="#零花费标识" class="headerlink" title="零花费标识"></a>零花费标识</h2><p>在这中间有两部分极度不对称。objc_msgSend侧每秒跑数亿次并且需要尽可能快。另一方面，改变缓存大小是一个少见的操作，且通常随着程序的运行变得越来越少见。一旦程序达到平稳状态，不再加载新代码或者编辑消息列表，并且缓存变得足够大时，改变缓存大小的操作将不再发生。在那之前，它可能发生数百或者数千次直到缓存增大到符合需求的大小，但是和objc_msgSend操作相比，它是非常少的，而且对性能的影响也是很小的。</p>
<p>因为这种不对称，最好在消息发送侧尽可能小，即使它会使缓存释放部分变慢。在每个缓存空闲操作中以100万个CPU周期为代价削减objc_msgSend中的一个CPU周期，这是一个极大的胜利。</p>
<p>即使一个全局的计数器是花费巨大的。这是objc_msgSend种的两个额外的内存访问，会增加大量的开销。他们需要具备atomic和使用memory barrier。幸好，Objective-C runtime有一种技术可以使objc_msgSend得花销降到0，其代价是使缓存释放变的更慢。</p>
<p>全局计数器的目的是追踪任何线程是否在特定的代码区域内。线程已经有了跟踪他们当前正在运行的代码的东西：程序计数器。这是跟踪当前指令内存地址的CPU寄存器。我们可以检查每个线程的程序计数器，看它是否在objc_msgSend中，而不是用全局计数器。如果所有线程都在外面，那么释放旧缓存是安全的。伪码如下：</p>
<pre><code>BOOL ThreadsInMsgSend(void) {
    for(thread in GetAllThreads()) {
        uniptr_t pc = thread.GetPC();
        if (pc &gt;= objc_msgsend_startAddresss &amp;&amp; pc &lt;= objc_msgSend_endAddress) {
            return YES;
        }
    }
    return NO;
}

bucket_t *oldCache = class-&gt;cache;
class-&gt;cache = malloc(newSize);
append(gOldCacheList, oldCache);
if(!ThreadsInMsgSend) {
    for (cache in gOldCacheList) {
        free(cache);
    }
    gOldCacheList.clear();
}</code></pre><p>objc_msgSend根本没做任何特殊的事情。它可以直接访问缓存，而不用担心标记访问。伪码如下：</p>
<pre><code>lookUpCache(class-&gt;cache);</code></pre><h2 id="真实的代码"><a href="#真实的代码" class="headerlink" title="真实的代码"></a>真实的代码</h2><p>Apple的实现能在runtime函数_collecting_in_critical中看到，它在objc-cache.mm中。<br>至关重要的程序计数器存储在全局变量中：</p>
<pre><code>OBJC_EXPORT uinptr_t objc_entryPoints[];
OBJC_EXPORT uinptr_t objc_exit Points[];</code></pre><p>实际上有多个objc_msgSend实现（像struct返回），内部的cache_getImp函数也直接访问缓存。他们都需要被检查从而安全释放缓存。</p>
<p>函数本身不带任何参数，并返回int，它只是作为一个布尔标志来表示是否有任何线程处于关键函数中：</p>
<pre><code>static int _collecting_in_critical(void) {</code></pre><p>我将跳过这个函数中不那么有趣的代码，以便集中精力于最好的部分。如果你想看到整个实现，请参阅opensource.apple.com。</p>
<p>获取线程信息的API位于内核级。 task_threads获得一个给定任务中的所有线程的列表（内核进程的术语），这个代码使用它来获取在自己的进程中的线程：</p>
<pre><code>ret = task_threads(mach_task_self(), &amp;threads, &amp;number);</code></pre><p>这将返回线程中的thread_t值的数组，以及数量中的线程数。然后循环它们：</p>
<pre><code>for (count = 0; count &lt; number; count++) {</code></pre><p>为一个线程提取程序计数器是在一个单独的函数中完成的，我们简短的看以下：</p>
<pre><code>pc = _get_pc_for_thread (threads[count]);</code></pre><p>然后在入口点和出口点循环，并与每个点进行比较：</p>
<pre><code>     for (region = 0; objc_entryPoints[region] != 0; region++) {
         if ((pc &gt;= objc_entryPoints[region]) &amp;&amp; (pc &lt;= objc_exitPoints[region])) {
             result = TRUE;
             goto done;
         }
     }
}</code></pre><p>循环之后，它将结果返回给调用者：</p>
<pre><code>  return result;
}</code></pre><p>_get_pc_for_thread函数是如何工作的？这是一个比较简单的代码，调用thread_get_state来获得目标线程的寄存器状态。它在一个单独的函数中的主要原因是因为寄存器状态结构是特定于架构的，因为每个架构都有不同的寄存器。这意味着这个函数需要为每个支持的体系架构单独实现，尽管实现几乎完全相同。这是x86-64的实现：</p>
<pre><code>static uintptr_t _get_pc_for_thread(thread_t thread)
{
    x86_thread_state64_t            state;
    unsigned int count = x86_THREAD_STATE64_COUNT;
    kern_return_t okay = thread_get_state (thread, x86_THREAD_STATE64, (thread_state_t)&amp;state, &amp;count);
    return (okay == KERN_SUCCESS) ? state.__rip : PC_SENTINEL;
}</code></pre><p>请注意，rip是x86-64上PC的寄存器名称; R代表“注册”，IP代表“指令指针”。</p>
<p>入口点和出口点本身在汇编语言文件中定义。他们看起来像这样：</p>
<pre><code>.private_extern _objc_entryPoints
_objc_entryPoints:
    .quad   _cache_getImp
    .quad   _objc_msgSend
    .quad   _objc_msgSend_fpret
    .quad   _objc_msgSend_fp2ret
    .quad   _objc_msgSend_stret
    .quad   _objc_msgSendSuper
    .quad   _objc_msgSendSuper_stret
    .quad   _objc_msgSendSuper2
    .quad   _objc_msgSendSuper2_stret
    .quad   0

.private_extern _objc_exitPoints
_objc_exitPoints:
    .quad   LExit_cache_getImp
    .quad   LExit_objc_msgSend
    .quad   LExit_objc_msgSend_fpret
    .quad   LExit_objc_msgSend_fp2ret
    .quad   LExit_objc_msgSend_stret
    .quad   LExit_objc_msgSendSuper
    .quad   LExit_objc_msgSendSuper_stret
    .quad   LExit_objc_msgSendSuper2
    .quad   LExit_objc_msgSendSuper2_stret
    .quad   0</code></pre><p>_collecting_in_critical函数的使用方法和在上面的假设例子中非常类似。在释放缓存垃圾的代码之前调用它。runtime实际上有两个独立的模式：一个是如果其他线程处于关键函数，则留下缓存垃圾；另一个是不停循环直到清除完缓存垃圾，并总是释放缓存垃圾：</p>
<pre><code>// Synchronize collection with objc_msgSend and other cache readers
if (!collectALot) {
    if (_collecting_in_critical ()) {
        // objc_msgSend (or other cache reader) is currently looking in
        // the cache and might still be using some garbage.
        if (PrintCaches) {
            _objc_inform (&quot;CACHES: not collecting; &quot;
                          &quot;objc_msgSend in progress&quot;);
        }
        return;
    }
}
else {
    // No excuses.
    while (_collecting_in_critical())
        ;
}

// free garbage here</code></pre><p>第一种模式，把垃圾留到下一次，用于正常缓存大小调整。循环模式总是释放在运行时的方法产生的缓存垃圾，并且刷新所有类的所有缓存，因为这通常会产生大量的垃圾。从代码中可以看出，只有在启用将所有消息发送到文件的调试日志记录工具时才会发生这种情况。它会刷新缓存，因为消息缓存会干扰日志记录。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>性能和线程安全往往彼此相互矛盾。访问和共享数据往往存在不对称性，这使得线程安全性更高。全局标志或计数器能够指出哪些操作访问数据是不安全的。在Objective-C runtime中，Apple更进一步的使用每个线程的程序计数器来指出线程何时执行不安全操作。这是一个专门的案例，很难看到这个技术在哪里会用到，但是分析它很有趣。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mikeash.com/pyblog/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime.html" target="_blank" rel="noopener">Concurrent Memory Deallocation in the Objective-C Runtime</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/29/Objective-C-Runtime%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/" data-id="ck736a2ql0014ees65kzf1hgj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/" rel="tag">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Actuator/" rel="tag">Actuator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flink/" rel="tag">Flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flume/" rel="tag">Flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Grafana/" rel="tag">Grafana</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/" rel="tag">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVO/" rel="tag">KVO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C/" rel="tag">Objective-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prometheus/" rel="tag">Prometheus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/" rel="tag">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/akka/" rel="tag">akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/block/" rel="tag">block</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flink/" rel="tag">flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runloop/" rel="tag">runloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime/" rel="tag">runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scrapy/" rel="tag">scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/" rel="tag">函数派发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E8%BF%9E/" rel="tag">响应连</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E9%92%A5/" rel="tag">密钥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Actuator/" style="font-size: 12.5px;">Actuator</a> <a href="/tags/Flink/" style="font-size: 12.5px;">Flink</a> <a href="/tags/Flume/" style="font-size: 10px;">Flume</a> <a href="/tags/Grafana/" style="font-size: 10px;">Grafana</a> <a href="/tags/Hadoop/" style="font-size: 12.5px;">Hadoop</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Objective-C/" style="font-size: 20px;">Objective-C</a> <a href="/tags/Prometheus/" style="font-size: 10px;">Prometheus</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Spring-Boot/" style="font-size: 12.5px;">Spring Boot</a> <a href="/tags/Swift/" style="font-size: 12.5px;">Swift</a> <a href="/tags/akka/" style="font-size: 10px;">akka</a> <a href="/tags/block/" style="font-size: 10px;">block</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/kafka/" style="font-size: 12.5px;">kafka</a> <a href="/tags/runloop/" style="font-size: 10px;">runloop</a> <a href="/tags/runtime/" style="font-size: 10px;">runtime</a> <a href="/tags/scrapy/" style="font-size: 10px;">scrapy</a> <a href="/tags/%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/" style="font-size: 10px;">函数派发</a> <a href="/tags/%E5%93%8D%E5%BA%94%E8%BF%9E/" style="font-size: 10px;">响应连</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 10px;">安全</a> <a href="/tags/%E5%AF%86%E9%92%A5/" style="font-size: 10px;">密钥</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">机器学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 17.5px;">源码分析</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Flink%E7%BD%91%E7%BB%9C%E6%A0%88%E5%8F%8A%E8%83%8C%E5%8E%8B%E7%9B%91%E6%8E%A7/">深入理解Flink网络栈及背压监控</a>
          </li>
        
          <li>
            <a href="/2019/11/08/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Flink%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%EF%BC%9A%E4%BF%A1%E5%B0%81%E8%83%8C%E8%AE%A1%E7%AE%97%E6%B3%95/">如何计算Flink集群规模：信封背计算法</a>
          </li>
        
          <li>
            <a href="/2018/12/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8Hadoop%E9%9B%86%E7%BE%A4/">如何搭建高可用Hadoop集群</a>
          </li>
        
          <li>
            <a href="/2018/11/13/Akka%E5%9C%A8Flink%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">Akka在Flink中的应用</a>
          </li>
        
          <li>
            <a href="/2018/08/19/Spring-Boot-Metrics%E7%9B%91%E6%8E%A7%E4%B9%8BPrometheus-Grafana/">Spring Boot Metrics监控之Prometheus&amp;Grafana</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 MrHup<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>